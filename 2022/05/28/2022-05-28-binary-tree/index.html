<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="二叉树二叉树是一种天然适配分治法的数据结构，许多二叉树问题都可以使用“分而治之”的思想来解决。遇到二叉树问题，就想想整棵树的结果与它左右子树的结果有什么关系。 分治法天然适配“递归”程式，所以，很多分治问题都可以用递归函数实现。但递归函数不是唯一的实现方式。 二叉树的遍历二叉树的遍历方式有两类、四种：  深度优先遍历 前序 中序 后序   宽度优先遍历 层序     从图中可以看出，在深度优先遍历">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树与分治法">
<meta property="og:url" content="https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/index.html">
<meta property="og:site_name" content="Clover Code">
<meta property="og:description" content="二叉树二叉树是一种天然适配分治法的数据结构，许多二叉树问题都可以使用“分而治之”的思想来解决。遇到二叉树问题，就想想整棵树的结果与它左右子树的结果有什么关系。 分治法天然适配“递归”程式，所以，很多分治问题都可以用递归函数实现。但递归函数不是唯一的实现方式。 二叉树的遍历二叉树的遍历方式有两类、四种：  深度优先遍历 前序 中序 后序   宽度优先遍历 层序     从图中可以看出，在深度优先遍历">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gaoshu883.github.io/images/2022-05-28/1.jpg">
<meta property="og:image" content="https://gaoshu883.github.io/images/2022-05-28/2.jpg">
<meta property="article:published_time" content="2022-05-27T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-05T06:56:37.295Z">
<meta property="article:author" content="Wang Xiaolu">
<meta property="article:tag" content="二叉树">
<meta property="article:tag" content="分治法">
<meta property="article:tag" content="DFS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gaoshu883.github.io/images/2022-05-28/1.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/logo.png">
        
      
      
      
    
    <!-- title -->
    <title>二叉树与分治法</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.1.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2022/06/16/2022-06-16-dfs/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2022/05/19/2022-05-19-bfs/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&text=二叉树与分治法"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&title=二叉树与分治法"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&is_video=false&description=二叉树与分治法"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=二叉树与分治法&body=Check out this article: https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&title=二叉树与分治法"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&title=二叉树与分治法"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&title=二叉树与分治法"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&title=二叉树与分治法"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&name=二叉树与分治法&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&t=二叉树与分治法"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.</span> <span class="toc-text">二叉树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%86%E6%B2%BB%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.2.</span> <span class="toc-text">二叉树分治法模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.</span> <span class="toc-text">非递归中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-LCA"><span class="toc-number">1.4.</span> <span class="toc-text">最近公共祖先 (LCA)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%9E%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">题型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST"><span class="toc-number">2.</span> <span class="toc-text">二叉搜索树 (BST)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">2.1.</span> <span class="toc-text">BST的构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">插入节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E7%9A%84%E4%BF%AE%E5%89%AA"><span class="toc-number">2.3.</span> <span class="toc-text">BST的修剪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E4%B8%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">2.4.</span> <span class="toc-text">BST上查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.5.</span> <span class="toc-text">红黑树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LintCode-%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">LintCode 练习题</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        二叉树与分治法
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Wang Xiaolu</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-05-27T16:00:00.000Z" class="dt-published" itemprop="datePublished">2022-05-28</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/DFS/" rel="tag">DFS</a>, <a class="p-category" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a>, <a class="p-category" href="/tags/%E5%88%86%E6%B2%BB%E6%B3%95/" rel="tag">分治法</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是一种天然适配分治法的数据结构，许多二叉树问题都可以使用“分而治之”的思想来解决。遇到二叉树问题，就想想<strong>整棵树的结果与它左右子树的结果有什么关系</strong>。</p>
<p>分治法天然适配“递归”程式，所以，很多分治问题都可以用递归函数实现。但递归函数不是唯一的实现方式。</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历方式有两类、四种：</p>
<ul>
<li>深度优先遍历<ul>
<li>前序</li>
<li>中序</li>
<li>后序</li>
</ul>
</li>
<li>宽度优先遍历<ul>
<li>层序</li>
</ul>
</li>
</ul>
<p><img src="/images/2022-05-28/1.jpg" alt="二叉树的遍历"></p>
<p>从图中可以看出，在深度优先遍历中，即使有前中后三种类型，但遍历的路径是一样的，不同的只是访问根节点的时机。</p>
<h3 id="二叉树分治法模板"><a href="#二叉树分治法模板" class="headerlink" title="二叉树分治法模板"></a>二叉树分治法模板</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">divide_conquer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 1. 递归出口</span>
    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> something
    <span class="token comment"># 2. 处理左右子树</span>
    left_result <span class="token operator">=</span> divide_conquer<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    right_result <span class="token operator">=</span> divide_conquer<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token comment"># 3. 合并结果</span>
    result <span class="token operator">=</span> left_result <span class="token operator">+</span> right_result <span class="token operator">+</span> root
    
    <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>重点提炼：</p>
<ul>
<li>分治法的关键在于合并左右子树结果得到最终结果</li>
<li><strong>分治法不使用全局变量</strong>，递归函数有返回值</li>
<li>若使用了全局变量，说明用到了遍历法思想</li>
</ul>
<h3 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h3><p>非递归解法是指使用栈数据结构，手动回溯，实现深度优先遍历。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">inorder_traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment"># 1. 创建 dummy node （虚拟节点）</span>
    dummy <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    dummy<span class="token punctuation">.</span>right <span class="token operator">=</span> root <span class="token comment"># 很巧妙的设计</span>
    stack <span class="token operator">=</span> <span class="token punctuation">[</span>dummy<span class="token punctuation">]</span>

    inorder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token comment"># 访问栈</span>
    <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
        <span class="token comment"># pop -> 回溯</span>
        <span class="token comment"># push 右子树根节点</span>
        <span class="token comment"># push          所有的左子树（深度优先遍历右子树）</span>
        node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
            cur_root <span class="token operator">=</span> node<span class="token punctuation">.</span>right
            <span class="token keyword">while</span> cur_root<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur_root<span class="token punctuation">)</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>left
        <span class="token keyword">if</span> stack<span class="token punctuation">:</span>
            inorder<span class="token punctuation">.</span>append<span class="token punctuation">(</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> inorder<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>重点提炼：</p>
<ol>
<li>总是要一次性把左子树节点入栈，这也是深度优先的本质所在</li>
<li>当左子树为空，通过<strong>出栈实现回溯</strong>，再压入右子树根节点</li>
<li>重复步骤 1 的操作</li>
</ol>
<h3 id="最近公共祖先-LCA"><a href="#最近公共祖先-LCA" class="headerlink" title="最近公共祖先 (LCA)"></a>最近公共祖先 (LCA)</h3><h4 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h4><ul>
<li>有父指针：找到两个点的路径，从根开始比较，最后一个相同的点是他们的 LCA</li>
<li>无父指针：分治法。下列解法仅针对 A、B 两点一定存在的情景，如果 A、B 两点不一定存在，递归函数需要额外返回 A、B 是否存在。<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    @param: root: The root of the binary tree.
    @param: A: A TreeNode in a Binary.
    @param: B: A TreeNode in a Binary.
    @return: Return the least common ancestor(LCA) of the two nodes.
    """</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token comment"># 1. 根节点是 A or B，祖先就是 root</span>
        <span class="token keyword">if</span> root <span class="token operator">==</span> A <span class="token keyword">or</span> root <span class="token operator">==</span> B<span class="token punctuation">:</span>
            <span class="token keyword">return</span> root
        <span class="token comment"># 左右子树递归</span>
        left <span class="token operator">=</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">)</span>
        right <span class="token operator">=</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">)</span>
        <span class="token comment"># 2. 左右子树分别存在A、B祖先，则 root 为 A、B 祖先</span>
        <span class="token keyword">if</span> left <span class="token keyword">and</span> right<span class="token punctuation">:</span>
            <span class="token keyword">return</span> root
        <span class="token comment"># 3. LCA 在左子树</span>
        <span class="token keyword">if</span> left<span class="token punctuation">:</span>
            <span class="token keyword">return</span> left
        <span class="token comment"># 4. LCA 在右子树</span>
        <span class="token keyword">if</span> right<span class="token punctuation">:</span>
            <span class="token keyword">return</span> right
        
        <span class="token keyword">return</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><code>git rebase</code> 用到了 LCA。<code>git rebase</code>和<code>git merge</code>的功能相似，用于合并两个分支的代码，只不过相较于<code>merge</code>，使用<code>rebase</code>可以让提交历史变成一条线。<code>git rebase</code>的工作流程和原理是：</p>
<ul>
<li>假设我们处于<code>feature</code>分支，执行<code>git rebase master</code>用于合并<code>master</code>分支的代码</li>
<li>git 先找到<code>feature</code>和<code>master</code>俩分支的最近公共祖先 (LCA)</li>
<li>将<code>feature</code>分支上 LCA 之后的 commit 以<code>master</code>为基创建新的 commit</li>
</ul>
<p><img src="/images/2022-05-28/2.jpg" alt="git rebase"></p>
<h2 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树 (BST)"></a>二叉搜索树 (BST)</h2><p>性质：中序遍历有序（单调不减）</p>
<p>基本操作：创建、遍历、查找、插入、删除</p>
<h3 id="BST的构造"><a href="#BST的构造" class="headerlink" title="BST的构造"></a>BST的构造</h3><p><strong>如何从有序数组中构造平衡二叉搜索树？</strong></p>
<p>最先想到的可能是构造普通BST的方法：遍历数组，依次向树中插入节点。很明显，这样的方法会导致基于有序数组构造出来的二叉树退化为链表。为了保证平衡，左右子树的节点数量最好平分，然后这样递归下去，这棵二叉树就一定是平衡的了。所以，只需要把数组平分成两部分，确保每部分都是一棵平衡二叉树，那么最终整棵树就是平衡的。</p>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p><strong>如果这个节点的值已存在，怎么办？</strong></p>
<p>当插入一个节点，若它不和树上已有值重复，则它一定是以叶子节点的身份插入。若有重复，可以让新节点作为重复点右子树最小点的左子树（当右子树存在时）。</p>
<h3 id="BST的修剪"><a href="#BST的修剪" class="headerlink" title="BST的修剪"></a>BST的修剪</h3><p>特别喜欢下面这个解决方案，很奇妙！</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    @param root: given BST
    @param minimum: the lower limit
    @param maximum: the upper limit
    @return: the root of the new tree 
    """</span>
    <span class="token keyword">def</span> <span class="token function">trim_b_s_t</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> minimum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> maximum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>
        <span class="token comment"># write your code here</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        
        <span class="token comment"># 之所以要修剪，是因为有满足条件的、还有不满足条件的</span>
        <span class="token comment"># 丢弃完全不满足条件的（副作用在这里）</span>
        <span class="token keyword">if</span> minimum <span class="token operator">&lt;=</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> maximum<span class="token punctuation">:</span>
            <span class="token comment"># 左右枝都得修剪</span>
            root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>trim_b_s_t<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> minimum<span class="token punctuation">,</span> maximum<span class="token punctuation">)</span>
            root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>trim_b_s_t<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> minimum<span class="token punctuation">,</span> maximum<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> minimum<span class="token punctuation">:</span>
            <span class="token comment"># 直接丢弃左枝，同时继续修剪右枝</span>
            root <span class="token operator">=</span> self<span class="token punctuation">.</span>trim_b_s_t<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> minimum<span class="token punctuation">,</span> maximum<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># 直接丢弃右枝，同时继续修剪左枝</span>
            root <span class="token operator">=</span> self<span class="token punctuation">.</span>trim_b_s_t<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> minimum<span class="token punctuation">,</span> maximum<span class="token punctuation">)</span>
        
        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="BST上查找"><a href="#BST上查找" class="headerlink" title="BST上查找"></a>BST上查找</h3><p>这类问题和<a href="/2022/05/13/2022-05-13-binary-search/#%E9%97%AE%E9%A2%98%E7%B1%BB%E5%9E%8B">二分查找题型</a>相似。要么是查找 target，要么是查找最接近 target 的某（几）个值。</p>
<p>暴力解法：先中序遍历得到有序数组，然后再利用二分查找解决问题。这个解法比较容易想到和理解。</p>
<p>分治法：</p>
<ul>
<li>先思考“整棵树的结果与它左右子树的结果有什么关系”</li>
<li>以“查找最接近 target 的某个值”问题为例，整棵树的结果，是<code>[左子树的最接近值、根的值、右子树的最接近值]</code>中与 target 最接近的值，这部分也是算法的核心<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    @param root: the given BST
    @param target: the given target
    @return: the value in the BST that is closest to the target
    """</span>
    <span class="token keyword">def</span> <span class="token function">closest_value</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># write your code here</span>
        <span class="token comment"># 如何使用分治法解决此题</span>
        <span class="token comment"># 左孩子、根、右孩子</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span>
        left_val <span class="token operator">=</span> self<span class="token punctuation">.</span>closest_value<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
        right_val <span class="token operator">=</span> self<span class="token punctuation">.</span>closest_value<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span>

        <span class="token keyword">if</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">-</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>left_val <span class="token operator">-</span> target<span class="token punctuation">)</span> <span class="token keyword">and</span> \
        <span class="token builtin">abs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">-</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>right_val <span class="token operator">-</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> root<span class="token punctuation">.</span>val
        <span class="token keyword">if</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>left_val <span class="token operator">-</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>right_val <span class="token operator">-</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> left_val
        <span class="token keyword">return</span> right_val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>即使去查找k个最接近的值，分治法的解法也是类似的，即从<code>左子树的k个值、[根的值]、右子树的k个值</code>中返回最接近的k个值。</li>
</ul>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>本质上也是平衡二叉树（Self-balancing binary search tree），但是它是相对平衡，不似 AVL (Adelson-Velsky and Landis Tree) 那样严格保证左右子树高度相差不超过 1。</p>
<h2 id="LintCode-练习题"><a href="#LintCode-练习题" class="headerlink" title="LintCode 练习题"></a>LintCode 练习题</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/67/">67 简单</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/1359/">1359 简单</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/85/">85 简单</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/701/">701 中等</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/86/">86 困难</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/900/">900 简单</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/901/">901 困难</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/902/">902 中等</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/453/">453 简单</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/596/">596 简单</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/474/">474 简单</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/88/">88 中等</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/578/">578 中等</a></li>
</ul>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-hans/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">图片1来源</a><br><a target="_blank" rel="noopener" href="https://www.daolf.com/posts/git-series-part-2/">图片2来源</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.</span> <span class="toc-text">二叉树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%86%E6%B2%BB%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.2.</span> <span class="toc-text">二叉树分治法模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.</span> <span class="toc-text">非递归中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-LCA"><span class="toc-number">1.4.</span> <span class="toc-text">最近公共祖先 (LCA)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%9E%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">题型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST"><span class="toc-number">2.</span> <span class="toc-text">二叉搜索树 (BST)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">2.1.</span> <span class="toc-text">BST的构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">插入节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E7%9A%84%E4%BF%AE%E5%89%AA"><span class="toc-number">2.3.</span> <span class="toc-text">BST的修剪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E4%B8%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">2.4.</span> <span class="toc-text">BST上查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.5.</span> <span class="toc-text">红黑树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LintCode-%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">LintCode 练习题</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&text=二叉树与分治法"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&title=二叉树与分治法"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&is_video=false&description=二叉树与分治法"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=二叉树与分治法&body=Check out this article: https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&title=二叉树与分治法"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&title=二叉树与分治法"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&title=二叉树与分治法"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&title=二叉树与分治法"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&name=二叉树与分治法&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://gaoshu883.github.io/2022/05/28/2022-05-28-binary-tree/&t=二叉树与分治法"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    Wang Xiaolu
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
