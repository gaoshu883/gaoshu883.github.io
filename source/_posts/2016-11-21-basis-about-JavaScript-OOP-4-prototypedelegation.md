---

title: "JavaScript之OOP基础概念学习总结四：prototype delegation"
date: 2016-11-21
tag: ["javascript"]
category: ["Web前端"]
---

### 说在前面的话

都说JavaScript中的一切都是对象，JavaScript中没有类，是通过对象继承对象，来实现内存节约以及代码复用的。具体实现的方法是原型链，更具体地叫做原型委托，prototype delegation：我可以没有这个属性（数据），但是我通过原型委托，循着原型链（failing lookup），从而在别的对象上找到相对应的属性（数据）和方法。


但是，你是否深入思考过，我们为什么要原型委托，为什么非得搞这么复杂的一套语言设计模式，直接老老实实地编写代码不行吗？当然可以，但是如果你真这么做，就太不懂变通了。没有解决不了的问题，所以关键是采取什么样的方法。编程人员在经历了很多之后发现：实现代码复用是非常重要的一件事。信息化技术需要的就是高效、海量，如果时间浪费在编写原本就已经存在的代码上，你的工作变得毫无意义，计算机也不会发挥出它的全部价值。所以，实现代码复用很重要，是基础建设，是每种编程语言都着重考虑的问题。编程语言中的类、继承、原型链等概念都是在为代码复用这个核心问题而服务。也是我们学习编程语言，最重要的一部分。


上面说这么多，其实就是想让自己加深对代码复用这个编程语言设计思想的印象，在此基础之上再去理解什么是原型链、对象继承，或许就不会有特别多的困扰了。突然想到之前看过的一篇文章，里面提到，人之所以会纠结、会困扰，多是因为自己不知道要去干什么。所以，当我们知道自己是要做计算机编程的核心问题之一：代码复用、节约内存占用的时候，再去学习有关原型链、继承方面的知识，也就会有些通彻了。你能够给做的每一件事都找到理由，岂不是特别得爽？

### 代码复用的策略

为了实现代码复用，我们主要讨论两种策略，如下图所示：一种是直接复制需要的代码，另一种则是原型委托（我不复制，但是我和你建立联系，从而interpreter能够去你——原型对象那里继续查找）。

![代码复用的策略](/images/2016-11-21-prototype/1.png)

第一种方式：直接复制对象，并不能随时保证同步，因为复制操作是一次性的。就像git版本控制一样，你本地更新后，远端并没有更新；远端更新后，本地并没有更新，需要手动git push 或者git pull。但是第二种方式就不一样了，因为不是复制，只是建立连接，所以对象更新后，就能直接通过连接反映过来。

现在，我们已经对比了上述两种不同的实现代码复用的策略，发现还是第二种方式更好，接下来我们就要正式深入地探究第二种方式中涉及到的原型问题了。

### Object.prototype

上面提到的第二种方式，最关键的点在于原型链。我们并不直接完全复制某对象，还是把某对象当做原型，通过委托机制（告诉某对象，我想把你做当我的原型，希望能够访问你的数据，使用你的方法），实现某对象上的属性查找。所有的对象都有一个原型链的终点，那就是Object.prototype原型对象。这里存储的属性是所有对象共有的。不管是哪条原型链上的对象，它们的属性lookup都能到达Object.prototype对象（如果属性存储在这个对象中时，比如toString方法）。

![Object.prototype](/images/2016-11-21-prototype/2.png)

### Object.prototype.constructor

上面我们提到了原型链的终点对象，提到这个对象中存在着一些实例对象的共享属性，现在我们就要说说其中一个属性`.constructor`。

![Object.prototype.constructor](/images/2016-11-21-prototype/3.png)

>Like all properties, .constructor actually points to a different object that's stored elsewhere.

尤其需要注意的是，Object.prototype.constructor指向一个对象，也就是构造器对象，它和原型对象是两个不同的对象，存储空间不一样，所以不能混淆。

每一个对象都有constructor属性，但是这个属性其实是对象的原型对象的constructor属性。其实对象并没有local constructor property，但是它通过原型委托，沿着原型链能够在原型对象上找到这个constructor属性。实例对象最终还是间接得通过自己固有的原型属性推断自己的构造函数是哪儿个。*怪不得实例对象感慨：我为什么非得通过原型母亲才能知道自己的构造器父亲是谁啊。*所有的这一切都是因为我们要实现代码复用，减少内存占用。很多时候，我们只能通过间接的方式，也就是原型委托找到需要查询的属性，这虽然有点麻烦，但是这点麻烦在代码复用面前都是芝麻大的小事。

### Array.prototype

如果你在创建对象的时候没有什么特别指示或者处理的话，对象的直接原型对象也即原型链的终点对象是Object.prototype对象。但是如果你做了一些特殊的指示或者要求，情况就大不相同了。这个时候，你可能需要委托其他的原型对象，比如Array.prototype对象。Array.prototype对象中存储着一些Object.prototype对象没有的属性和方法，但是也存储着和Object.prototype对象中一样的属性和方法，比如constructor属性。此外，还要注意的是，Object.prototype对象始终都是原型链的终点对象，也就是说，Array.prototype也会委托于Object.prototype。这条原型链相较于之前讨论的那条，就多了一个Array.prototype原型链节了，如下图所示：

![Array.prototype](/images/2016-11-21-prototype/4.png)

### 总结

还记得我们正式探讨原型链前，说的那个有关代码复用的问题吗？是的，你必须时刻记得代码复用这个十分重要的编程目的。这门编程语言中有原型链的概念，就是为了让我们能够进行代码复用（共享），同时节省内存。（因为有了原型链，我们就不用再编写已经存在的属性和方法——避免重复的代码编写工作）

### 参考资料

所有图片截取自[Object-Oriented JavaScript](https://cn.udacity.com/course/object-oriented-javascript--ud015)相关视频