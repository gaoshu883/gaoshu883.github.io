<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>哈希表精华总结</title>
      <link href="/2022/07/10/2022-07-10-hashtable/"/>
      <url>/2022/07/10/2022-07-10-hashtable/</url>
      
        <content type="html"><![CDATA[<p>哈希表是以 <code>key:value</code> 形式存储数据的数据结构，以 O(1) 的时间复杂度实现增删改查。哈希表的存储过程如下图所示：</p><p><img src="/images/2022-07-10/hash-table.png" alt="哈希表原理示意图"></p><p>哈希表的底层是列表，key 通过哈希函数转换到列表的索引，对应的索引位中存储了 value，而这个索引也叫做哈希值。</p><h2 id="哈希函数的算法实现"><a href="#哈希函数的算法实现" class="headerlink" title="哈希函数的算法实现"></a>哈希函数的算法实现</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">hash_code</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''    @param key: 要被hash的字符串    @param hash_size: 哈希表的长度    '''</span>    ans <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> key<span class="token punctuation">:</span>        ans <span class="token operator">=</span> <span class="token punctuation">(</span>ans <span class="token operator">*</span> <span class="token number">33</span> <span class="token operator">+</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> hash_size    <span class="token keyword">return</span> ans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="哈希表的应用"><a href="#哈希表的应用" class="headerlink" title="哈希表的应用"></a>哈希表的应用</h2><p>哈希表一般用于构造各类复杂的数据结构，比如文本重点介绍的 LRU 算法。</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>LRU (Least Recently Used) 最近最少使用，是一种页面置换算法，用于操作系统的内存管理。一些内存数据库，例如 Redis 会将该算法用作缓存淘汰策略。之所以 LRU 热度高，是因为它的性能好，接近于最佳置换算法。</p><p>与 LRU 算法类似的一种算法叫 LFU (Least Frequently Used) 最少访问算法。LRU 是时间维度上的度量，长时间没用到的数据优先考虑淘汰；而 LFU 是统计度量，使用次数最少的数据优先考虑淘汰。</p><p>Python 中提供的 OrderedDict 数据类型可便于 LRU 算法的实现。OrderedDict 是 dict 子类，它保留了 <code>key:value</code> 插入字典的顺序。当更新某个 key 对应的 value 时，默认不会更新键值对的位置，可利用 <code>move_to_end</code> 方法手动将修改的键值对移动到最后。最后，可利用 <code>popitem</code> 方法按照“先进先出”或“后进先出”的规则删除键值对。</p><h2 id="LintCode-练习题"><a href="#LintCode-练习题" class="headerlink" title="LintCode 练习题"></a>LintCode 练习题</h2><ul><li><a href="https://www.lintcode.com/problem/128/">128 简单</a></li><li><a href="https://www.lintcode.com/problem/685/">685 中等</a></li><li><a href="https://www.lintcode.com/problem/960/">960 中等</a></li><li><a href="https://www.lintcode.com/problem/657/">657 中等</a></li><li><a href="https://www.lintcode.com/problem/134/">134 困难</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度优先搜索精华总结</title>
      <link href="/2022/06/16/2022-06-16-dfs/"/>
      <url>/2022/06/16/2022-06-16-dfs/</url>
      
        <content type="html"><![CDATA[<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>DFS 会优先考虑最近新遇到的搜索状态，所以算法会沿着一条路一直往下走，直到遇到目标状态或者走到底。如果走到底，就后退一步，换条路继续走。同一个路径中不走重复点，不同的路径可能会走重复点。</p><p>在总结<a href="/2022/05/28/2022-05-28-binary-tree/">二叉树</a>相关问题时，深度优先搜索已经用起来了，只不过被归结为“分治法”。分治法的核心是权衡<strong>整棵树的结果与它左右子树的结果有什么关系</strong>，通常利用递归函数来实现。</p><p>不仅仅是二叉树，我们还可能面对数组、图等数据结构，本文将总结更多有关深度优先搜索的应用。</p><h2 id="二叉树中的应用"><a href="#二叉树中的应用" class="headerlink" title="二叉树中的应用"></a>二叉树中的应用</h2><p>请查看<a href="/2022/05/28/2022-05-28-binary-tree/">二叉树与分治法</a>。</p><h2 id="数组中的应用"><a href="#数组中的应用" class="headerlink" title="数组中的应用"></a>数组中的应用</h2><p>对数组元素的<strong>排列和组合</strong>会用到 DFS。在解决排列和组合问题时，我们会构造出一棵 N 叉树的解空间。比如数组<code>[1,2,3]</code>的所有子集可表示成下图：<br><img src="/images/2022-06-16/dfs.jpg" alt="[1,2,3]的(a)所有子集(b)全排列"></p><p>也就是说，即使面对的是数组，但解决的问题本质还是树的遍历或搜索。既然是普通树的搜索问题，也就可以沿用二叉树的解决思路，考量<strong>整棵树的结果与它各个子树的结果有什么关系</strong>。</p><p>我们更常使用递归函数实现数组中的 DFS 算法，时间复杂度为：O(方案总数 * 每个方案所花费的时间)。</p><h3 id="所有组合"><a href="#所有组合" class="headerlink" title="所有组合"></a>所有组合</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> index<span class="token punctuation">,</span> root_paths<span class="token punctuation">,</span> results<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''    @param nums: 原始输入数组    @param index: 父级路径中最后一点在 nums 中的索引    @param root_paths: 父级路径，也就是已经访问过的点列表    @param results: 答案列表    '''</span>    <span class="token keyword">if</span> 递归出口<span class="token punctuation">:</span>        <span class="token keyword">return</span>    results<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root_paths<span class="token punctuation">)</span>    <span class="token comment"># 遍历每个孩子，向前看不走回头路</span>    <span class="token comment"># 从 index+1 开始，确保是未访问的点</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 如果有重复元素则跳过</span>        <span class="token comment"># i - 1 和 i 都是没有访问过的</span>        <span class="token keyword">if</span> i <span class="token operator">></span> index <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">continue</span>        <span class="token comment"># 深拷贝得到孩子节点</span>        root_list_with_child <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        root_list_with_child<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> root_list_with_child<span class="token punctuation">,</span> results<span class="token punctuation">)</span>    <span class="token keyword">return</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点提炼：</p><ul><li>将该模板与<strong>二叉树分治法模板</strong>对比，可以看出，两个算法的本质是相似的，都是将任务交给<strong>每个孩子</strong>递归处理。</li><li>解决此类问题的口诀是：<span style="color:red">访问根节点，分配孩子做</span>，问题的难点在于“找孩子”。</li><li>什么时候需要<strong>有序</strong>的数组：<ul><li>题目要求每个组合中的元素必须有序</li><li>数组中有重复元素时，排序有助去重</li></ul></li></ul><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> root_paths<span class="token punctuation">,</span> results<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''    @param nums: 原始输入数组    @param visited: 某条路径上已经访问过的点索引集合    @param root_paths: 父级路径，也就是已经访问过的点列表    '''</span>    <span class="token comment"># 找到了一种全排列</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>root_paths<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        results<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root_paths<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token comment"># 分配孩子去做事情</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 排除掉 root_paths，其他都是孩子</span>        <span class="token comment"># root_paths 都是 visited 的</span>        <span class="token keyword">if</span> i <span class="token keyword">in</span> visited<span class="token punctuation">:</span>            <span class="token keyword">continue</span>        <span class="token comment"># 如果有重复元素则跳过</span>        <span class="token comment"># i - 1 和 i 都是没有访问过的，则 i-1 和 i 都是孩子索引</span>        <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">not</span> <span class="token keyword">in</span> visited <span class="token keyword">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">continue</span>                root_list_with_child <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>root_paths<span class="token punctuation">)</span>        root_list_with_child<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        visited_with_child <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span>visited<span class="token punctuation">)</span>        visited_with_child<span class="token punctuation">.</span>add<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        dfs<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> visited_with_child<span class="token punctuation">,</span> root_list_with_child<span class="token punctuation">,</span> results<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点提炼：</p><ul><li>数组中有重复元素时，需要先对数组进行排序</li><li>visited 记录的是路径上已经走过的点</li></ul><h2 id="图中的应用"><a href="#图中的应用" class="headerlink" title="图中的应用"></a>图中的应用</h2><p>图上使用 DFS，必须记录<span style="color:red">已访问过</span>信息，而且这个信息是同一条链路上的，不同的链路不会共享该信息。解决此类问题，需要依循的核心是：</p><p><strong>根据归并思想，采用递归函数，<span style="color:red">分配孩子去做事</span>。</strong></p><p>解题时，就想想前面给出的模板，举一反三。题目难点往往在于<strong>终止递归的条件</strong>，因为提前终止是对算法的优化。</p><h2 id="DFS-vs-BFS"><a href="#DFS-vs-BFS" class="headerlink" title="DFS vs BFS"></a>DFS vs BFS</h2><p>有关 BFS 的内容可以查看<a href="/2022/05/19/2022-05-19-bfs/">此文</a>，本文简要说明两种算法的不同。</p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>DFS 和 BFS 都是要访问所有的孩子，不同的是，DFS 把孩子加入栈，BFS 把孩子加入队列。所以，DFS 总是处理最新发现的点，而 BFS 总是处理最先发现的点。取值顺序的不同，就造成了深度扩展和宽度扩展的区别。因此，BFS 具有天然寻找最短路径的属性，DFS 具有天然记录当前路径的属性。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p><strong>时间复杂度</strong> DFS 和 BFS 一致<br><strong>空间复杂度</strong> DFS 取决于深度， BFS 取决于宽度</p><h2 id="LintCode-练习题"><a href="#LintCode-练习题" class="headerlink" title="LintCode 练习题"></a>LintCode 练习题</h2><ul><li><a href="https://www.lintcode.com/problem/17/">17 中等</a></li><li><a href="https://www.lintcode.com/problem/18/">18 中等</a></li><li><a href="https://www.lintcode.com/problem/15/">15 中等</a></li><li><a href="https://www.lintcode.com/problem/16/">16 中等</a></li><li><a href="https://www.lintcode.com/problem/425/">425 中等</a></li><li><a href="https://www.lintcode.com/problem/90/">90 中等</a></li><li><a href="https://www.lintcode.com/problem/135/">135 中等</a></li><li><a href="https://www.lintcode.com/problem/132/">132 困难</a></li><li><a href="https://www.lintcode.com/problem/121/">121 困难</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树与分治法</title>
      <link href="/2022/05/28/2022-05-28-binary-tree/"/>
      <url>/2022/05/28/2022-05-28-binary-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是一种天然适配分治法的数据结构，许多二叉树问题都可以使用“分而治之”的思想来解决。遇到二叉树问题，就想想<strong>整棵树的结果与它左右子树的结果有什么关系</strong>。</p><p>分治法天然适配“递归”程式，所以，很多分治问题都可以用递归函数实现。但递归函数不是唯一的实现方式。</p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历方式有两类、四种：</p><ul><li>深度优先遍历<ul><li>前序</li><li>中序</li><li>后序</li></ul></li><li>宽度优先遍历<ul><li>层序</li></ul></li></ul><p><img src="/images/2022-05-28/1.jpg" alt="二叉树的遍历"></p><p>从图中可以看出，在深度优先遍历中，即使有前中后三种类型，但遍历的路径是一样的，不同的只是访问根节点的时机。</p><h3 id="二叉树分治法模板"><a href="#二叉树分治法模板" class="headerlink" title="二叉树分治法模板"></a>二叉树分治法模板</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">divide_conquer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 1. 递归出口</span>    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> something    <span class="token comment"># 2. 处理左右子树</span>    left_result <span class="token operator">=</span> divide_conquer<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>    right_result <span class="token operator">=</span> divide_conquer<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token comment"># 3. 合并结果</span>    result <span class="token operator">=</span> left_result <span class="token operator">+</span> right_result <span class="token operator">+</span> root        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点提炼：</p><ul><li>分治法的关键在于合并左右子树结果得到最终结果</li><li><strong>分治法不使用全局变量</strong>，递归函数有返回值</li><li>若使用了全局变量，说明用到了遍历法思想</li></ul><h3 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h3><p>非递归解法是指使用栈数据结构，手动回溯，实现深度优先遍历。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">inorder_traversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># 1. 创建 dummy node （虚拟节点）</span>    dummy <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    dummy<span class="token punctuation">.</span>right <span class="token operator">=</span> root <span class="token comment"># 很巧妙的设计</span>    stack <span class="token operator">=</span> <span class="token punctuation">[</span>dummy<span class="token punctuation">]</span>    inorder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># 访问栈</span>    <span class="token keyword">while</span> stack<span class="token punctuation">:</span>        <span class="token comment"># pop -> 回溯</span>        <span class="token comment"># push 右子树根节点</span>        <span class="token comment"># push          所有的左子树（深度优先遍历右子树）</span>        node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>            cur_root <span class="token operator">=</span> node<span class="token punctuation">.</span>right            <span class="token keyword">while</span> cur_root<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur_root<span class="token punctuation">)</span>                node <span class="token operator">=</span> node<span class="token punctuation">.</span>left        <span class="token keyword">if</span> stack<span class="token punctuation">:</span>            inorder<span class="token punctuation">.</span>append<span class="token punctuation">(</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> inorder<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点提炼：</p><ol><li>总是要一次性把左子树节点入栈，这也是深度优先的本质所在</li><li>当左子树为空，通过<strong>出栈实现回溯</strong>，再压入右子树根节点</li><li>重复步骤 1 的操作</li></ol><h3 id="最近公共祖先-LCA"><a href="#最近公共祖先-LCA" class="headerlink" title="最近公共祖先 (LCA)"></a>最近公共祖先 (LCA)</h3><h4 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h4><ul><li>有父指针：找到两个点的路径，从根开始比较，最后一个相同的点是他们的 LCA</li><li>无父指针：分治法。下列解法仅针对 A、B 两点一定存在的情景，如果 A、B 两点不一定存在，递归函数需要额外返回 A、B 是否存在。<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    @param: root: The root of the binary tree.    @param: A: A TreeNode in a Binary.    @param: B: A TreeNode in a Binary.    @return: Return the least common ancestor(LCA) of the two nodes.    """</span>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token comment"># 1. 根节点是 A or B，祖先就是 root</span>        <span class="token keyword">if</span> root <span class="token operator">==</span> A <span class="token keyword">or</span> root <span class="token operator">==</span> B<span class="token punctuation">:</span>            <span class="token keyword">return</span> root        <span class="token comment"># 左右子树递归</span>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">)</span>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">)</span>        <span class="token comment"># 2. 左右子树分别存在A、B祖先，则 root 为 A、B 祖先</span>        <span class="token keyword">if</span> left <span class="token keyword">and</span> right<span class="token punctuation">:</span>            <span class="token keyword">return</span> root        <span class="token comment"># 3. LCA 在左子树</span>        <span class="token keyword">if</span> left<span class="token punctuation">:</span>            <span class="token keyword">return</span> left        <span class="token comment"># 4. LCA 在右子树</span>        <span class="token keyword">if</span> right<span class="token punctuation">:</span>            <span class="token keyword">return</span> right                <span class="token keyword">return</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><code>git rebase</code> 用到了 LCA。<code>git rebase</code>和<code>git merge</code>的功能相似，用于合并两个分支的代码，只不过相较于<code>merge</code>，使用<code>rebase</code>可以让提交历史变成一条线。<code>git rebase</code>的工作流程和原理是：</p><ul><li>假设我们处于<code>feature</code>分支，执行<code>git rebase master</code>用于合并<code>master</code>分支的代码</li><li>git 先找到<code>feature</code>和<code>master</code>俩分支的最近公共祖先 (LCA)</li><li>将<code>feature</code>分支上 LCA 之后的 commit 以<code>master</code>为基创建新的 commit</li></ul><p><img src="/images/2022-05-28/2.jpg" alt="git rebase"></p><h2 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树 (BST)"></a>二叉搜索树 (BST)</h2><p>性质：中序遍历有序（单调不减）</p><p>基本操作：创建、遍历、查找、插入、删除</p><h3 id="BST的构造"><a href="#BST的构造" class="headerlink" title="BST的构造"></a>BST的构造</h3><p><strong>如何从有序数组中构造平衡二叉搜索树？</strong></p><p>最先想到的可能是构造普通BST的方法：遍历数组，依次向树中插入节点。很明显，这样的方法会导致基于有序数组构造出来的二叉树退化为链表。为了保证平衡，左右子树的节点数量最好平分，然后这样递归下去，这棵二叉树就一定是平衡的了。所以，只需要把数组平分成两部分，确保每部分都是一棵平衡二叉树，那么最终整棵树就是平衡的。</p><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p><strong>如果这个节点的值已存在，怎么办？</strong></p><p>当插入一个节点，若它不和树上已有值重复，则它一定是以叶子节点的身份插入。若有重复，可以让新节点作为重复点右子树最小点的左子树（当右子树存在时）。</p><h3 id="BST的修剪"><a href="#BST的修剪" class="headerlink" title="BST的修剪"></a>BST的修剪</h3><p>特别喜欢下面这个解决方案，很奇妙！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    @param root: given BST    @param minimum: the lower limit    @param maximum: the upper limit    @return: the root of the new tree     """</span>    <span class="token keyword">def</span> <span class="token function">trim_b_s_t</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> minimum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> maximum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> TreeNode<span class="token punctuation">:</span>        <span class="token comment"># write your code here</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>                <span class="token comment"># 之所以要修剪，是因为有满足条件的、还有不满足条件的</span>        <span class="token comment"># 丢弃完全不满足条件的（副作用在这里）</span>        <span class="token keyword">if</span> minimum <span class="token operator">&lt;=</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> maximum<span class="token punctuation">:</span>            <span class="token comment"># 左右枝都得修剪</span>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>trim_b_s_t<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> minimum<span class="token punctuation">,</span> maximum<span class="token punctuation">)</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>trim_b_s_t<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> minimum<span class="token punctuation">,</span> maximum<span class="token punctuation">)</span>        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> minimum<span class="token punctuation">:</span>            <span class="token comment"># 直接丢弃左枝，同时继续修剪右枝</span>            root <span class="token operator">=</span> self<span class="token punctuation">.</span>trim_b_s_t<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> minimum<span class="token punctuation">,</span> maximum<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 直接丢弃右枝，同时继续修剪左枝</span>            root <span class="token operator">=</span> self<span class="token punctuation">.</span>trim_b_s_t<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> minimum<span class="token punctuation">,</span> maximum<span class="token punctuation">)</span>                <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BST上查找"><a href="#BST上查找" class="headerlink" title="BST上查找"></a>BST上查找</h3><p>这类问题和<a href="/2022/05/13/2022-05-13-binary-search/#%E9%97%AE%E9%A2%98%E7%B1%BB%E5%9E%8B">二分查找题型</a>相似。要么是查找 target，要么是查找最接近 target 的某（几）个值。</p><p>暴力解法：先中序遍历得到有序数组，然后再利用二分查找解决问题。这个解法比较容易想到和理解。</p><p>分治法：</p><ul><li>先思考“整棵树的结果与它左右子树的结果有什么关系”</li><li>以“查找最接近 target 的某个值”问题为例，整棵树的结果，是<code>[左子树的最接近值、根的值、右子树的最接近值]</code>中与 target 最接近的值，这部分也是算法的核心<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    @param root: the given BST    @param target: the given target    @return: the value in the BST that is closest to the target    """</span>    <span class="token keyword">def</span> <span class="token function">closest_value</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># write your code here</span>        <span class="token comment"># 如何使用分治法解决此题</span>        <span class="token comment"># 左孩子、根、右孩子</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span>        left_val <span class="token operator">=</span> self<span class="token punctuation">.</span>closest_value<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span>        right_val <span class="token operator">=</span> self<span class="token punctuation">.</span>closest_value<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">-</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>left_val <span class="token operator">-</span> target<span class="token punctuation">)</span> <span class="token keyword">and</span> \        <span class="token builtin">abs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">-</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>right_val <span class="token operator">-</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> root<span class="token punctuation">.</span>val        <span class="token keyword">if</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>left_val <span class="token operator">-</span> target<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>right_val <span class="token operator">-</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> left_val        <span class="token keyword">return</span> right_val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>即使去查找k个最接近的值，分治法的解法也是类似的，即从<code>左子树的k个值、[根的值]、右子树的k个值</code>中返回最接近的k个值。</li></ul><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>本质上也是平衡二叉树（Self-balancing binary search tree），但是它是相对平衡，不似 AVL (Adelson-Velsky and Landis Tree) 那样严格保证左右子树高度相差不超过 1。</p><h2 id="LintCode-练习题"><a href="#LintCode-练习题" class="headerlink" title="LintCode 练习题"></a>LintCode 练习题</h2><ul><li><a href="https://www.lintcode.com/problem/67/">67 简单</a></li><li><a href="https://www.lintcode.com/problem/1359/">1359 简单</a></li><li><a href="https://www.lintcode.com/problem/85/">85 简单</a></li><li><a href="https://www.lintcode.com/problem/701/">701 中等</a></li><li><a href="https://www.lintcode.com/problem/86/">86 困难</a></li><li><a href="https://www.lintcode.com/problem/900/">900 简单</a></li><li><a href="https://www.lintcode.com/problem/901/">901 困难</a></li><li><a href="https://www.lintcode.com/problem/902/">902 中等</a></li><li><a href="https://www.lintcode.com/problem/453/">453 简单</a></li><li><a href="https://www.lintcode.com/problem/596/">596 简单</a></li><li><a href="https://www.lintcode.com/problem/474/">474 简单</a></li><li><a href="https://www.lintcode.com/problem/88/">88 中等</a></li><li><a href="https://www.lintcode.com/problem/578/">578 中等</a></li></ul><p>参考资料：<br><a href="https://zh.m.wikipedia.org/zh-hans/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">图片1来源</a><br><a href="https://www.daolf.com/posts/git-series-part-2/">图片2来源</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 分治法 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宽度优先搜索精华总结</title>
      <link href="/2022/05/19/2022-05-19-bfs/"/>
      <url>/2022/05/19/2022-05-19-bfs/</url>
      
        <content type="html"><![CDATA[<p>图的遍历或搜索可以用 BFS 和 DFS 算法实现，本文介绍的是 BFS 算法。BFS 每次都会选择尝试<strong>最先发现</strong>的但还没有尝试过的选项。</p><h2 id="问题类型"><a href="#问题类型" class="headerlink" title="问题类型"></a>问题类型</h2><p>BFS 算法应用的场景主要有以下几类：</p><ul><li>连通性（块）、最短路径</li><li>树、图分层遍历</li><li>拓扑排序</li></ul><h2 id="连通性、最短路径"><a href="#连通性、最短路径" class="headerlink" title="连通性、最短路径"></a>连通性、最短路径</h2><p>图的遍历可利用 BFS 算法实现，反过来，<strong>通过 BFS 算法可以得到一个图</strong>，这也是利用 BFS 解决连通性、岛屿相关问题的本质。</p><p>可以使用 BFS 算法求解最短路径的图通常满足以下特点：无向、无权、没有自环和重边（平行边）。</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bfs</span><span class="token punctuation">(</span>start_node<span class="token punctuation">,</span> end_node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 初始节点入队</span>    <span class="token comment"># distance 缓存已经访问过的节点，同时记录节点与初始节点的距离</span>    <span class="token comment"># 如果只考虑连通性，就不需要记录距离</span>    queue <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span>start_node<span class="token punctuation">]</span><span class="token punctuation">)</span>    distance <span class="token operator">=</span> <span class="token punctuation">&#123;</span>start_node<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">&#125;</span>        <span class="token comment"># 访问队列，每次取出一个节点</span>    <span class="token comment"># 此处会循环 V 次，V 表示图的顶点个数</span>    <span class="token keyword">while</span> queue<span class="token punctuation">:</span>        node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 如果有明确的终点</span>        <span class="token keyword">if</span> node <span class="token operator">==</span> end_node<span class="token punctuation">:</span>            <span class="token keyword">break</span> <span class="token keyword">or</span> <span class="token keyword">return</span> something        <span class="token comment"># 把当前节点相邻的、且没有访问过的节点加入队列</span>        <span class="token comment"># 紧接着对加入队列的节点打上标记</span>        <span class="token comment"># 此处会循环 Eaj 次，Eaj 表示当前顶点的邻边数量</span>        <span class="token keyword">for</span> neighbor <span class="token keyword">in</span> node<span class="token punctuation">.</span>get_neighbors<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> neighbor <span class="token keyword">in</span> distance<span class="token punctuation">:</span>                <span class="token keyword">continue</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span>            distance<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">=</span> distance<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token comment"># 返回所有点离起点的最短距离</span>    <span class="token keyword">return</span> distance    <span class="token comment"># 返回所有连通的节点</span>    <span class="token keyword">return</span> distance<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 返回起点离终点的最短距离</span>    <span class="token keyword">return</span> distance<span class="token punctuation">[</span>end_node<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="题解分析"><a href="#题解分析" class="headerlink" title="题解分析"></a>题解分析</h3><ul><li>流程速记：初始化 -&gt; 访问队列 -&gt; 扩展邻居</li><li>利用哈希表去重，入队后要立刻打标记</li><li><strong><code>get_neighbors</code> 是解题的关键</strong><ul><li>在图这种数据结构中，<code>neighbors</code> 用于存储边</li><li>很多时候需要根据题目中的条件确定 <code>neighbors</code><ul><li>单词接龙中，单词 a 根据规则变化到的单词都是 a 的 neighbors</li></ul></li><li>BFS解决的通常都是应用题，需要我们自己梳理顶点和边</li></ul></li></ul><h3 id="分层写法"><a href="#分层写法" class="headerlink" title="分层写法"></a>分层写法</h3><p>常应用于分层遍历。分层的主要根据：<strong>留在队列里的永远是同一层的节点</strong>，遍历这些节点，加入其子节点。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 访问队列，每次循环遍历队列里的节点</span><span class="token keyword">while</span> queue<span class="token punctuation">:</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> node 是终点<span class="token punctuation">:</span>            <span class="token keyword">break</span> <span class="token keyword">or</span> <span class="token keyword">return</span> something        <span class="token comment"># 把当前节点相邻的、且没有访问过的节点加入队列</span>        <span class="token comment"># 紧接着对加入队列的节点打上标记</span>        <span class="token keyword">for</span> neighbor <span class="token keyword">in</span> node<span class="token punctuation">.</span>get_neighbors<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> neighbor <span class="token keyword">in</span> distance<span class="token punctuation">:</span>                <span class="token keyword">continue</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span>            distance<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">=</span> distance<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>在 BFS 算法中，一共有两层循环，外层是对所有的顶点遍历，<strong>内层是对当前顶点的邻边遍历</strong>。我们有以下的计算过程：</p><pre class="line-numbers language-none"><code class="language-none">  O(V) * (O(1) + O(Eaj)) &#x3D; O(V) + O(V * Eaj) &#x3D; O(V) + O(E)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，E 为图中所有的边。</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>此类问题出现在有向无环图中，在于找到一个可执行的序列，此序列包含图中<strong>所有顶点</strong>。比如大学选课问题，N 种课程因前后依赖关系构成一张图，让找出一种课程学习的顺序。</p><h3 id="算法模板-1"><a href="#算法模板-1" class="headerlink" title="算法模板"></a>算法模板</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">def</span> <span class="token function">get_indegrees</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">:</span>    counter <span class="token operator">=</span> <span class="token punctuation">&#123;</span>node<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token keyword">for</span> node <span class="token keyword">in</span> nodes<span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> node <span class="token keyword">in</span> nodes<span class="token punctuation">:</span>        <span class="token keyword">for</span> neighbor <span class="token keyword">in</span> node<span class="token punctuation">.</span>get_neighbors<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            counter<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> counter<span class="token keyword">def</span> <span class="token function">topological_sort</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 1. 统计图上所有点的入度</span>    indegrees <span class="token operator">=</span> get_indegrees<span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>    <span class="token comment"># 2. 将所有入度为 0 的点加入队列中</span>    queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> node <span class="token keyword">in</span> indegrees<span class="token punctuation">:</span>        <span class="token keyword">if</span> indegrees<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token comment"># 3. 访问队列，pop 点，并把邻接点的入度-1</span>    <span class="token comment"># 4. 当邻接点的入度为 0，则将其加入队列中</span>    topo_order <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">while</span> queue<span class="token punctuation">:</span>        node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        topo_order<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>                <span class="token keyword">for</span> neighbor <span class="token keyword">in</span> node<span class="token punctuation">.</span>get_neighbors<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            indegrees<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> indegrees<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>topo_order<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token comment"># 有环，没有拓扑序列</span>    <span class="token keyword">return</span> topo_order<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解题分析"><a href="#解题分析" class="headerlink" title="解题分析"></a>解题分析</h3><ul><li>解决拓扑排序问题，第一步是构建图<ul><li>构建图有时候会成为一个难点，需要具体问题具体分析得到图的边和点。</li><li>构建图通常是解题的关键，因为拓扑排序的套路比较固定，如模板所示。</li></ul></li></ul><h2 id="LintCode-练习题"><a href="#LintCode-练习题" class="headerlink" title="LintCode 练习题"></a>LintCode 练习题</h2><ul><li><a href="https://www.lintcode.com/problem/69/">69 简单</a></li><li><a href="https://www.lintcode.com/problem/137/">137 中等</a></li><li><a href="https://www.lintcode.com/problem/120/">120 困难</a></li><li><a href="https://www.lintcode.com/problem/433/">433 简单</a></li><li><a href="https://www.lintcode.com/problem/611/">611 中等</a></li><li><a href="https://www.lintcode.com/problem/616/">616 中等</a></li><li><a href="https://www.lintcode.com/problem/127/">127 中等</a></li><li><a href="https://www.lintcode.com/problem/892/">892 困难</a></li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>算法模板来源：<a href="https://github.com/ninechapter-algorithm/linghu-algorithm-templete">github</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相向双指针算法</title>
      <link href="/2022/05/16/2022-05-16-two-pointers/"/>
      <url>/2022/05/16/2022-05-16-two-pointers/</url>
      
        <content type="html"><![CDATA[<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>双指针算法常用于数组、字符串和链表等数据结构的搜索问题。双指针算法是原地算法，时间复杂度是<code>O(n)</code>，不使用额外的空间。根据指针的移动方向不同，又被分成：</p><ul><li>相向双指针</li><li>同向双指针</li><li>背向双指针</li></ul><p>本文的重点是<code>相向双指针</code>。</p><h2 id="问题类型"><a href="#问题类型" class="headerlink" title="问题类型"></a>问题类型</h2><p>相向双指针常用于解决的问题类型如下所示：</p><ul><li>Two Sum</li><li>Partition</li><li>Reverse</li></ul><p>其中，<code>Two Sum</code> 和 <code>Partition</code> 更为常见，它们的对比分析如下表所示。</p><table><thead><tr><th>类型</th><th>Two Sum</th><th>Partition</th></tr></thead><tbody><tr><td>问题描述</td><td>查找满足条件的具体方案或方案数量</td><td>分割数组，把相同类型的元素划分到一起</td></tr><tr><td>数据结构</td><td><strong>有序</strong>的数组</td><td>数组，不要求有序</td></tr><tr><td>变形</td><td>三数之和、四数之和、k 数之和<br>三角形个数<br>…</td><td>分割成三组、k 组…</td></tr></tbody></table><h2 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h2><p>两数之和</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">two_sum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> nums<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>        total <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span>        <span class="token keyword">if</span> total <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>            left <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> total <span class="token operator">></span> target<span class="token punctuation">:</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span>left<span class="token punctuation">,</span> right<span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="LintCode-练习题"><a href="#LintCode-练习题" class="headerlink" title="LintCode 练习题"></a>LintCode 练习题</h3><ul><li><a href="https://www.lintcode.com/problem/56/">56 简单</a></li><li><a href="https://www.lintcode.com/problem/607/">607 简单</a></li><li><a href="https://www.lintcode.com/problem/57/">57 中等</a></li><li><a href="https://www.lintcode.com/problem/58/">58 中等</a></li><li><a href="https://www.lintcode.com/problem/382/">382 中等</a></li></ul><h3 id="哈希表解法"><a href="#哈希表解法" class="headerlink" title="哈希表解法"></a>哈希表解法</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">two_sum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">hash</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment"># 缓存等待成对的 value-index 映射</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token builtin">hash</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token builtin">hash</span><span class="token punctuation">[</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span>        <span class="token builtin">hash</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p><code>Two Sum</code> 变形题中求解具体方案的算法复杂度如下表所示：</p><table><thead><tr><th>题型</th><th>独立随机变量数</th><th>求具体方案的算法复杂度</th></tr></thead><tbody><tr><td>x+y &#x3D; a, a 是常数</td><td>1</td><td>O(n)</td></tr><tr><td>x+y+z &#x3D; 0</td><td>2</td><td>O(n^2)</td></tr><tr><td>w+x+y+z &#x3D; 0</td><td>3</td><td>O(n^3)</td></tr><tr><td>x+y &gt; z</td><td>3</td><td>O(n^3)</td></tr></tbody></table><h2 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h2><p><code>partition</code> 算法用于分割数组，有些时候只是解决另一个问题的其中一步。比如在“交错正负数”里，可以先用<code>partition</code> 把数组划分成正、负两部分，然后再交换。又比如在“快速排序”中，<code>partition</code> 划分数组是其核心步骤。</p><h3 id="算法模板-1"><a href="#算法模板-1" class="headerlink" title="算法模板"></a>算法模板</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''    将 nums 分割成 &lt;= target 和 > target 两部分    '''</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> nums<span class="token punctuation">:</span>        <span class="token keyword">return</span>    left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> right<span class="token punctuation">:</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> right <span class="token keyword">and</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">:</span>            left <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> right <span class="token keyword">and</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">:</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">if</span> left <span class="token operator">&lt;=</span> right<span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            left <span class="token operator">+=</span> <span class="token number">1</span>            right <span class="token operator">-=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果分割成三部分，可以使用两次双指针<code>partition</code>，或者直接使用三根指针，模板如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">partition2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''    将 nums 分成三部分： &lt;low 、 >high 、 >=low and &lt;=high    '''</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> nums<span class="token punctuation">:</span>        <span class="token keyword">return</span>        left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    i <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">:</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> low<span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            left <span class="token operator">+=</span> <span class="token number">1</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> high<span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            i <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="LintCode-练习题-1"><a href="#LintCode-练习题-1" class="headerlink" title="LintCode 练习题"></a>LintCode 练习题</h3><ul><li><a href="https://www.lintcode.com/problem/373/">373 简单</a></li><li><a href="https://www.lintcode.com/problem/49/">49 中等</a></li><li><a href="https://www.lintcode.com/problem/144/">144 中等</a></li><li><a href="https://www.lintcode.com/problem/148/">148 中等</a></li><li><a href="https://www.lintcode.com/problem/143/">143 中等</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Search 的原理</title>
      <link href="/2022/05/13/2022-05-13-binary-search/"/>
      <url>/2022/05/13/2022-05-13-binary-search/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>二分查找法背后的原理是：<strong>利用数据中的规律不断将搜索范围减半</strong>。通常这样的规律可以是数组有序——“升序”、“单调不减”等，但也不局限于此，可扩展到数据满足一定的函数关系，比如“先升后降”、“旋转数组”等。总之，这些规律可以为查找提供线索，从而缩小搜索范围。</p><h2 id="问题类型"><a href="#问题类型" class="headerlink" title="问题类型"></a>问题类型</h2><ul><li>查找 target 出现的任一 index</li><li>查找 &gt;&#x3D; target 的最小 index 或 value</li><li>查找 &lt;&#x3D; target 的最大 index 或 value</li><li>可插入 target 的 index</li><li>target 出现的次数</li></ul><h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">binary_search</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> nums<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    start<span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> start <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>            start <span class="token operator">=</span> mid        <span class="token keyword">else</span><span class="token punctuation">:</span>            end <span class="token operator">=</span> mid    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>        <span class="token keyword">return</span> start    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>        <span class="token keyword">return</span> end    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述<a href="https://github.com/ninechapter-algorithm/linghu-algorithm-templete">算法模板</a>巧妙运用了 <code>start + 1 &lt; end</code> 的循环条件，确保程序不会出现死循环，因为很多时候会因为<strong>临界点的判断</strong>而出现问题。循环结束后，再根据<code>[start, end]</code>区间端点的数值进行取舍，最后还要注意 fallback 的取值，不同类型的问题，fallback 不同，比如模版这里的 -1，表示没有找到 target。</p><h2 id="LintCode-练习题"><a href="#LintCode-练习题" class="headerlink" title="LintCode 练习题"></a>LintCode 练习题</h2><ul><li><a href="https://www.lintcode.com/problem/14/">14 简单</a></li><li><a href="https://www.lintcode.com/problem/460/">460 中等</a></li><li><a href="https://www.lintcode.com/problem/585/">585 中等</a></li><li><a href="https://www.lintcode.com/problem/159/">159 中等</a></li><li><a href="https://www.lintcode.com/problem/62/">62 中等</a></li><li><a href="https://www.lintcode.com/problem/75/">75 中等</a></li><li><a href="https://www.lintcode.com/problem/183/">183 困难</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的工作原理</title>
      <link href="/2017/03/19/2017-03-19-how-browser-works/"/>
      <url>/2017/03/19/2017-03-19-how-browser-works/</url>
      
        <content type="html"><![CDATA[<h3 id="1-影响浏览器渲染方式的文档模式"><a href="#1-影响浏览器渲染方式的文档模式" class="headerlink" title="1. 影响浏览器渲染方式的文档模式"></a>1. 影响浏览器渲染方式的文档模式</h3><p>每个浏览器都有自己的页面渲染引擎。渲染引擎包括两部分：一部分负责 HTML、CSS 代码的解析（渲染引擎，如 blink 引擎 or 内核），一部分负责 JavaScript 代码的解析（JavaScript 引擎，如 V8 引擎）。浏览器的渲染模式（以何种文档模式进行渲染）主要对 CSS 解析有影响（也对脚本有一些影响）。不同的渲染模式，在 CSS 解析上存在差异，比如对盒模型的处理。</p><p>不同的渲染模式是历史遗留问题造成的。早期 W3C 没统一标准，浏览器生产商自己决定页面如何渲染；标准出来后，现有浏览器渲染肯定存在与标准不同的地方。为了兼容，就出现了两种浏览器渲染模式（IE 最早提出），正统叫法为文档模式(Document Mode)（如果文档是按照标准编写的，浏览器采用标准渲染模式；如果文档并没有按照标准编写，那么浏览器以怪异模式渲染）。此外，还有第三种模式—近标准模式。那么浏览器又该如何知道文档有没有按照标准编写呢？实际上浏览器在渲染页面之前会检查两个内容，一个是页面是否有 <code>DOCTYPE</code> 信息，另外一个是页面是否有 <code>x-ua-compatible</code> 信息。<code>DOCTYPE</code> 告诉浏览器我的文档是哪种模式，你确定后，就按这种模式渲染；如果没有这个头信息，浏览器就按怪异模式渲染。<code>x-ua-compatible</code> 是 IE8 的一个专有<code>&lt;meta&gt;</code>属性，可以指定浏览器以怎样的模式进行渲染。</p><p><strong>注意：</strong>浏览器模式和浏览器渲染模式是两个概念，后者在本文中指文档模式。</p><h3 id="2-HTML-文档的解析过程"><a href="#2-HTML-文档的解析过程" class="headerlink" title="2. HTML 文档的解析过程"></a>2. HTML 文档的解析过程</h3><p>当用户在浏览器键入某网站地址，网站首页文档 <code>index.html</code> 加载完成后，浏览器开始解析 HTML。下文根据不同的 HTML 资源结构分析解析过程。</p><h4 id="2-1-纯-HTML-文档，无-CSS-和脚本"><a href="#2-1-纯-HTML-文档，无-CSS-和脚本" class="headerlink" title="2.1 纯 HTML 文档，无 CSS 和脚本"></a>2.1 纯 HTML 文档，无 CSS 和脚本</h4><p>如果 HTML 文档中只有 HTML，没有 CSS 和脚本的话，问题极其简单。浏览器解析 HTML，构建 DOM 树，DOM 树构建完成后（触发 <code>DOMContentLoaded</code> 事件），构建 render 树，接着布局和绘制像素。</p><h4 id="2-2-包含内联样式和内联脚本的-HTML-文档"><a href="#2-2-包含内联样式和内联脚本的-HTML-文档" class="headerlink" title="2.2 包含内联样式和内联脚本的 HTML 文档"></a>2.2 包含内联样式和内联脚本的 HTML 文档</h4><p>如果 HTML 文档中存在内联样式和脚本，这个时候，问题变得稍微复杂一些。浏览器解析 HTML，构建 DOM 树，当解析到<code>&lt;style&gt;</code>标签时，样式信息开始被解析，CSSOM 被构建，但是它并不会影响到 HTML 的解析和 DOM 树的构建。当 HTML 解析到<code>&lt;script&gt;</code>标签时，因为脚本有可能改变 DOM 内容，所以 HTML 的解析必须等到脚本执行完毕后再继续。脚本又有可能操作 CSSOM ，所以脚本必须等到 CSS 解析完毕后才能执行。确保此刻 CSS 解析完成，脚本被交到 JS 引擎手里，由 JS 引擎执行。当脚本执行完毕，HTML 继续解析，直到全部 HTML 解析完毕，DOM 树构建完成（触发 <code>DOMContentLoaded</code> 事件）。</p><p><strong>注意：</strong><code>DOMContentLoaded</code> 事件只和 HTML 的加载和解析有关，一旦 HTML 解析完成，这个事件就会被触发，不管此时还有没有CSS的解析、图片的下载或者异步脚本的加载和执行。DOM 树一旦构建完成，就会开始构建 render 树，并不管 CSS 是否解析完毕。如果构建 render 树的时候，CSS 还没有解析完成，那么 render 树会用占位符代替应该有的 CSSOM 节点，当该节点加载解析好后，再重新计算样式。</p><p>但是同步脚本的执行会阻塞 HTML 的解析，从而会影响到 <code>DOMContentLoaded</code> 事件的触发。同时又要注意，CSS 会阻塞 JS 脚本的执行，从而间接影响到 HTML 的解析和 <code>DOMContentLoaded</code> 事件的触发。</p><h4 id="2-3-包含外部-CSS-和脚本的-HTML-文档"><a href="#2-3-包含外部-CSS-和脚本的-HTML-文档" class="headerlink" title="2.3 包含外部 CSS 和脚本的 HTML 文档"></a>2.3 包含外部 CSS 和脚本的 HTML 文档</h4><p>如果 HTML 文档中存在外联样式表和脚本，问题变得更复杂一点。HTML 文档加载完成后，浏览器首先扫描 HTML 文档，查看有哪些外部资源需要启动 network operation 来请求资源，并在 HTML 解析的同时，发送所有的请求。CSS 资源加载完毕后，会立即开始解析构建 CSSOM。（同步脚本加载完毕后，并不能立刻执行。）当 HTML 解析到<code>&lt;script&gt;</code>标签，先确认脚本加载完毕了没。如果没，那得等；如果加载好了，还得看 CSS 解析好了没。如果没，那还得等；如果 CSS 解析好了，那就能把脚本交给 JS 引擎去执行了。当 JS 执行完毕，HTML 继续解析，DOM 继续构建，直到全部构建完成，<code>DOMContentLoaded</code> 事件被触发。紧接着，就是构建 render 树。</p><p>如果脚本有<code>async</code>属性，问题就又不一样了。<code>async</code>属性默认该脚本不会影响到 DOM 内容，所以只要脚本下载完成，（相关）CSS 解析完毕，脚本立刻执行，不用等着 HTML 解析到<code>&lt;script&gt;</code>标签再开始执行。同样，HTML 也不会等着脚本执行完毕再解析。仿佛两者看不到对方，只管做自己的事情就行了。</p><h3 id="3-JS-解释器的工作原理"><a href="#3-JS-解释器的工作原理" class="headerlink" title="3. JS 解释器的工作原理"></a>3. JS 解释器的工作原理</h3><p>上文提到浏览器在解析 HTML 文档的时候，会把脚本交给 JS 引擎执行，那么 JS 引擎是如何执行脚本(evaluating script)的呢？</p><h4 id="3-1-扫描全局变量，确定所有已声明的变量或函数名"><a href="#3-1-扫描全局变量，确定所有已声明的变量或函数名" class="headerlink" title="3.1 扫描全局变量，确定所有已声明的变量或函数名"></a>3.1 扫描全局变量，确定所有已声明的变量或函数名</h4><p>你如果利用 chrome 控制台调试 JS 代码，这个过程是看不到的，但确实存在。JS 解释器对脚本进行全局扫描，结束后得到全局环境中的变量对象，此过程发生了变量声明提升和函数声明提升。所有变量都没被赋值，其值为 <code>undefined</code>；函数声明提升还包括了函数体的提升。下图是个例子：</p><p><img src="/images/2017-03-broswer/1.png" alt="全局环境中的变量对象"></p><h4 id="3-2-顺序执行所有语句"><a href="#3-2-顺序执行所有语句" class="headerlink" title="3.2 顺序执行所有语句"></a>3.2 顺序执行所有语句</h4><p>当 JS 解释器知道整个文件中都有哪些声明好的全局变量或函数后，就会开始顺序执行文件中的语句，当然是从第一行开始。如果是赋值语句，就执行赋值操作；如果是函数调用语句，就执行函数调用。<br>下图是 debugger 刚开始时变量的情况，很明显，刚刚被 JS 解释器点过名，还没有开始执行赋值操作。</p><p><img src="/images/2017-03-broswer/2.png" alt="变量声明提升"></p><p>当解释器移动到下一行代码时，这个变量也就被赋值，存储了数据。在本例中这个数据是个对象类型，有两个属性，其中一个是数组，另一个是空值。</p><p><img src="/images/2017-03-broswer/3.png" alt="变量赋值操作"></p><p>脚本的最后是函数调用语句：</p><p><img src="/images/2017-03-broswer/4.png" alt="函数调用"></p><p>JS 解析器执行到这里，开始调用 octopus 的 init 方法。</p><p>当所有的语句执行完毕后，JS 解释器任务结束，主导权交到 HTML 解析器手中，浏览器继续解析 HTML 文档。</p><p>从上述过程，我们能看出浏览器解析渲染 HTML 文档是单线程的，除了发送外部资源请求的操作。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>浏览器的工作原理是网站性能优化的基础知识。CSS 不会阻塞 HTML 的解析，但是会阻塞渲染，CSS 的解析会阻塞脚本的执行，而脚本会阻塞 HTML 的解析。</p><p>后续会推出网站性能优化相关文章。</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建本地Web开发环境</title>
      <link href="/2017/02/05/2017-02-05-build-a-local-server/"/>
      <url>/2017/02/05/2017-02-05-build-a-local-server/</url>
      
        <content type="html"><![CDATA[<p>Web前端开发、测试通常需用到本地服务器，对本地服务器的需求基本上分为两种：HTTP静态服务器和Web+数据库服务器。</p><h3 id="1-HTTP静态服务器"><a href="#1-HTTP静态服务器" class="headerlink" title="1. HTTP静态服务器"></a>1. HTTP静态服务器</h3><p><strong>功能：</strong>针对静态网页测试，不需和数据库交互；</p><p><strong>工具：</strong>推荐使用nodejs平台下的httpster程序；</p><p><strong>使用步骤：</strong></p><ul><li>安装nodejs，nodejs下载地址：<a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a>；</li><li>全局安装httpster命令行，官方地址：<a href="https://simbco.github.io/httpster/">https://simbco.github.io/httpster/</a>；</li><li>如果你需要nodejs平台下的httpster程序之外的程序，可以参考<a href="https://gist.github.com/willurd/5720255">这里的列表</a>（包含各种开发平台下的程序），寻找适合你的静态web服务器程序。</li></ul><h3 id="2-Web-数据库服务器"><a href="#2-Web-数据库服务器" class="headerlink" title="2. Web+数据库服务器"></a>2. Web+数据库服务器</h3><p><strong>功能：</strong>针对动态网站开发测试，能够动态生成web页面，能够和数据库交互；</p><p><strong>工具：</strong>推荐使用phpstudy程序；除此之外，还可以使用XMAPP程序，但是这里推荐的phpstudy程序更加小巧方便，操作简单，容易上手。</p><p><strong>工具简介：</strong>phpStudy，该程序集成Apache（web server程序）+PHP（开发语言）+MySQL（数据库程序）+phpMyAdmin（用PHP编写的，可以通过 web 方式控制和操作 MySQL 数据库）+ZendOptimizer。</p><p><strong>使用步骤：</strong>具体使用步骤请参考<a href="build-local-server-for-ajax-development.html#post">搭建Ajax本地开发环境</a>这篇文章。</p><h3 id="3-实现内网穿透"><a href="#3-实现内网穿透" class="headerlink" title="3. 实现内网穿透"></a>3. 实现内网穿透</h3><p>成功搭建本地Web开发环境后，你可能需要外网测试，比如应用PageSpeed Insight工具测试网站首屏渲染性能，此时你需要内网穿透技能，具体实现方法请参考<a href="build-a-local-server.html#post">本地开发外网调试：httpster和ngrok</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建Ajax本地开发环境</title>
      <link href="/2017/02/05/2017-02-05-build-local-server-for-ajax-development/"/>
      <url>/2017/02/05/2017-02-05-build-local-server-for-ajax-development/</url>
      
        <content type="html"><![CDATA[<p>Ajax技术的目的在于实现异步请求，在不刷新整个页面的前提下，异步获取数据。</p><p>Ajax开发测试环境基于Web+数据库服务器。</p><p>搭建工具：<strong>phpStudy</strong>。</p><p>phpStudy，该程序集成Apache（web server程序）+PHP（开发语言）+MySQL（数据库程序）+phpMyAdmin（用PHP编写的，可以通过 web 方式控制和操作 MySQL 数据库）+ZendOptimizer。</p><p><strong>步骤</strong></p><p>我使用的是<a href="http://www.phpstudy.net/a.php/200.html">新手版 phpStudy Lite</a>，没有复杂的多版本设置，下载并安装在某盘根目录下。</p><p>需安装VC9运行库，因为这款phpStudy Lite的php和apache都是VC9编译，下载地址：32位的VC9运行库下载：<a href="http://www.microsoft.com/zh-CN/download/details.aspx?id=5582">http://www.microsoft.com/zh-CN/download/details.aspx?id=5582</a>，64位的VC9运行库下载：<a href="http://www.microsoft.com/zh-CN/download/details.aspx?id=15336">http://www.microsoft.com/zh-CN/download/details.aspx?id=15336</a>。</p><p>phpStudy操作界面如下图所示：</p><p><img src="/images/2017-02/phpStudy1.png" alt="phpStudy操作界面"></p><p>再来看一下phpStudy的目录：</p><p><img src="/images/2017-02/phpStudy2.png" alt="phpStudy安装目录"></p><p>在WWW目录下创建名为ajaxdemo的Web站点：</p><p><img src="/images/2017-02/ajaxdemo.png" alt="WWW目录下的ajaxdemo站点"></p><p>在浏览器地址栏输入<a href="http://localhost/ajaxdemo/%EF%BC%8C%E6%89%93%E5%BC%80ajaxdemo%E7%AB%99%E7%82%B9%E3%80%82">http://localhost/ajaxdemo/，打开ajaxdemo站点。</a></p><p><img src="/images/2017-02/ajaxdemo2.png" alt="ajaxdemo站点文档"></p><p>附注：站点文档来源：<a href="http://www.imooc.com/learn/250">慕课网-Ajax全接触</a></p><p>Ajaxdemo站点目录中保存了所有与该站点相关的文件，php文件是处理异步请求、和数据库产生交互的关键。</p><p>Ajax开发环境搭建完成，具体关于Ajax的操作请参考<a href="http://www.imooc.com/learn/250">慕课网-Ajax全接触</a>。</p><p>注意：上述过程并未涉及到数据库的使用，日后学习完续更。</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用Ngrok实现本地开发外网调试</title>
      <link href="/2017/02/05/2017-02-05-test-localhost-on-your-network/"/>
      <url>/2017/02/05/2017-02-05-test-localhost-on-your-network/</url>
      
        <content type="html"><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>Web开发需要联网试验和调试，通常做法是把网站上传至Web服务器，做成真实网站进行访问。</p><p>运行本地服务器只能本地访问，无法被其他电脑访问（无法通过外网访问）。</p><h3 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2. 解决方法"></a>2. 解决方法</h3><p>使用Ngrok，将本地网站映射到外网（外网访问内网）。由于Ngrok官网被墙，你可以选择使用<a href="https://www.ngrok.cc/">国内代理</a>，有免费和收费两种服务器。</p><p><strong>具体步骤：</strong></p><p><a href="https://www.ngrok.cc/">代理官网</a>下载Sunny-Ngrok程序，解压。注册并登陆<a href="http://www.ngrok.cc/login">隧道管理平台</a>，在<code>隧道管理&gt;开通隧道&gt;购买免费隧道&gt;</code>选项卡下填写以下内容：（确定添加后即可使用）</p><p><img src="/images/2017-02/ngrok.png" alt="ngrok国内代理隧道管理平台"></p><p><strong>注意：</strong>http验证用户和验证明码不要填，不然你就只能输入用户名和密码后才能访问网站，也就无法利用如pageSpeed Insight工具对网站进行测速。</p><p>在Sunny-Ngrok程序所在目录中，通过命令行工具执行<code>sunny clientid &lt;隧道id&gt;</code>指令，创建隧道，将本地网站映射到外网（各系统下均可）；或者双击运行<code>Sunny-Ngrok启动工具.bat</code>，键入<code>&lt;隧道id&gt;</code>即可（Windows系统下）。</p><p>使用提供的网址进行外网测试。</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Web前端工具分类</title>
      <link href="/2017/01/13/2017-01-13-tools-in-web-front-end/"/>
      <url>/2017/01/13/2017-01-13-tools-in-web-front-end/</url>
      
        <content type="html"><![CDATA[<p>Web前端开发技术不断发展，各种库、框架、模块管理、模块加载、构建工具层出不穷，然而对于初入Web深山的我来说，简直乱作一团。因为没有实际应用，往往分不清什么是库、什么是框架，构建工具是干什么的？模块为什么需要管理？加载又是怎么一回事。这些概念，会随着不断扩展学习和实际应用而变得清晰有形，但在此之前，先根据网上资料对这些概念有个大概的了解吧。</p><ul><li><strong>前端UI框架</strong>：Bootstrap、FrozenUI等。</li><li><strong>前端JavaScript框架</strong>：Reactjs，Vuejs，Angularjs，Backbonejs等（为了开发复杂的页面应用）；Reactjs，Vuejs都是view层，是库，不是完整的框架。</li><li><strong>前端工具（功能）库</strong>：jQuery、Zepto、Underscore、Lodash等。</li><li>**前端构建工具(Task runner)**：Gulp、Grunt、npm scripts等。</li><li><strong>前端模块管理器（包管理器）</strong>：Bower、Component、npm、Yarn等。</li><li>**前端模块化开发(Module bundler)**：Seajs &#x2F; Requirejs是模块加载器(module loader)；Browserify跟模块化相关，将CommonJS格式的服务器端模块编译成浏览器脚本；Webpack包含一部分Browserify的功能，但更专注于作为构建工具。</li><li>**JavaScript转换器(JS transpiler)**：Babel等（ES6转换成ES5）。</li><li><strong>JavaScript测试工具</strong>：Mocha、Jasmine、Jest等。</li></ul><p><strong>参考资料</strong></p><ul><li><a href="http://www.ruanyifeng.com/blog/2014/09/package-management.html">前端模块管理器简介</a></li><li><a href="https://www.awesomes.cn/repos/Applications/Frameworks">AweSomes——Web前端资源库</a></li><li><a href="https://ashleynolan.co.uk/blog/frontend-tooling-survey-2016-results">The State of Front-End Tooling 2016</a></li><li><a href="https://www.zhihu.com/question/24414899">npm、bower、jamjs 等包管理器，哪个比较好用？</a></li><li><a href="http://web.jobbole.com/86284/">别责怪框架：我使用 AngularJS 和 ReactJS 的经验</a></li><li><a href="http://www.infoq.com/cn/news/2016/02/gulp-grunt-npm-scripts-part1">我为何放弃Gulp与Grunt，转投npm scripts</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用Jekyll和GitHub Pages搭建静态博客网站</title>
      <link href="/2017/01/12/2017-01-12-building-website-using-jekyll-and-githubpages/"/>
      <url>/2017/01/12/2017-01-12-building-website-using-jekyll-and-githubpages/</url>
      
        <content type="html"><![CDATA[<p>网站刚建成那会儿，写过一篇建站后感 *<a href="what-is-Jekyll.html">Jekyll到底是什么？</a>*，文章部分涉及如何利用Jekyll搭建个人博客，但主要还是抒发建站感想的。而现在这篇文章，则是完全围绕如何建站，希望按照这篇文章能够原样创建一个博客网站。</p><h3 id="1-网站基础"><a href="#1-网站基础" class="headerlink" title="1. 网站基础"></a>1. 网站基础</h3><p><strong>何为网站</strong>：网页的集合</p><p><strong>网站的组成要素</strong>：客户端、服务器端、网页、传输</p><p><strong>各组成要素职责</strong>：</p><ul><li>客户端：显示网页</li><li>服务器端：存储网页</li><li>网页：呈现信息</li><li>传输：网页的转移（信息的传输）</li></ul><p><strong>何为静态网站</strong>：网页事先编写好后存储在服务器端</p><p><strong>何为动态网站</strong>：网页由服务器动态产生</p><p><strong>何为Jekyll</strong>：帮助我们快速搭建静态网站，快速是指不用编写复杂的网页，只需会写markdown文档即可（当然你完全可以自己编写网站样式、添加必要的前端交互效果）</p><p><strong>目标</strong>：将网站托管在github上，然后借助Jekyll快速搭建静态网站</p><h3 id="2-使用GitHub-Pages服务"><a href="#2-使用GitHub-Pages服务" class="headerlink" title="2. 使用GitHub Pages服务"></a>2. 使用GitHub Pages服务</h3><p>在GitHub上创建存放网站全部数据的仓库：</p><ul><li>在GitHub上创建一个名为username.github.io的仓库，username是你的GitHub用户名</li><li>为便于本地操作，通过git clone，把这个仓库克隆到本地硬盘上</li><li>当然，你完全可以在GitHub网页上直接操作</li></ul><p><strong>参考资料</strong></p><ul><li><a href="https://pages.github.com/">GitHub Pages官方网站</a></li></ul><h3 id="3-使用Jekyll"><a href="#3-使用Jekyll" class="headerlink" title="3. 使用Jekyll"></a>3. 使用Jekyll</h3><p>Jekyll是运行在Ruby平台上的程序，所以：</p><ul><li>首先搭建Jekyll工作环境</li><li>然后安装Jekyll工具</li><li>全部安装成功后，使用Jekyll工具</li></ul><h4 id="3-1-搭建Jekyll工作环境"><a href="#3-1-搭建Jekyll工作环境" class="headerlink" title="3.1 搭建Jekyll工作环境"></a>3.1 搭建Jekyll工作环境</h4><p>提前说明：下述步骤基于window10系统</p><ol><li>安装 Ruby &amp; Ruby Development Kit (下载网址：<a href="http://rubyinstaller.org/downloads/">http://rubyinstaller.org/downloads/</a> )</li><li>切换到Devkit的安装目录下，然后执行 <code>ruby dk.rb init</code></li><li><code>ruby dk.rb install</code></li><li><code>gem sources --add http://gems.ruby-china.org/ --remove http://rubygems.org/</code></li><li><code>gem install jekyll</code></li><li><code>gem install bundler</code></li></ol><p><strong>注释</strong></p><ul><li>dk.rb我认为是devkit ruby的缩写</li><li>DevKit 是windows平台下编译和使用本地C&#x2F;C++扩展包的工具。它就是用来模拟Linux平台下的make, gcc, sh来进行编译</li><li>DevKit 与gem的安装和更新有关，也就是说dk.rb的初始化和安装与gem有关</li><li>修改gem下载源地址是为了避免出现SSL问题</li><li><code>gem install jekyll bundler</code>是同时安装jekyll和bundler的指令</li><li>安装bundler是为了运行jekyll，直接运行<code>jekyll</code>可能会报错，通过<code>bundle exec jekyll</code>正常执行</li><li>到此，环境已经搭建完成</li></ul><h4 id="3-2-利用Jekyll建站（快速上手版）"><a href="#3-2-利用Jekyll建站（快速上手版）" class="headerlink" title="3.2 利用Jekyll建站（快速上手版）"></a>3.2 利用Jekyll建站（快速上手版）</h4><ol><li>切换至username.github.io目录下</li><li><code>jekyll new .</code></li><li>打开Gemfile配置文件，添加<code>gem &#39;wdm&#39;, &#39;&gt;= 0.1.0&#39;</code>代码（如果电脑系统是windows的话，否则跳过这一步）</li><li>在Gemfile中删除<code>gem &quot;jekyll&quot;</code>,增加<code>gem &quot;github-pages&quot;</code>（使用github pages服务）</li><li>执行<code>bundle install</code>指令</li><li><code>bundle exec jekyll serve</code></li><li>浏览博客网站：<a href="http://localhost:4000/">http://localhost:4000</a></li></ol><h4 id="3-3-利用Jekyll建站（基础详解版）"><a href="#3-3-利用Jekyll建站（基础详解版）" class="headerlink" title="3.3 利用Jekyll建站（基础详解版）"></a>3.3 利用Jekyll建站（基础详解版）</h4><p>当<code>jekyll new .</code>时，Jekyll网站自动搭建，如下所示：</p><pre><code>.(username.github.io)├── _drafts 博文草稿|   ├── begin-with-the-crazy-ideas.md|   └── on-simplicity-in-technology.md├── _includes 网页基本组件|   ├── footer.html|   └── header.html├── _layouts 网页模板|   ├── default.html|   └── post.html├── _posts 博文|   ├── 2007-10-29-why-every-programmer-should-play-nethack.md|   └── 2009-04-26-barcamp-boston-4-roundup.md├── _site `Jekyll build`生成的网站，在上传到github上时应忽略├── css 网站样式|   ├── main.css|   └── reset.css├── _config.yml 网站配置文件├── index.html 网站首页├── Gemfile 项目配置文件├── README.md 版本项目文档└── .gitignore</code></pre><p>除此之外 ，可自行按照网站目录树，手动创建所需文件。</p><p><strong>说明</strong></p><ul><li><code>jekyll new .</code>自动创建的文档和上述目录树并不完全一样</li><li>_config.yml是Jekyll网站的配置文件（内含网站相关信息，例如域名、作者、邮编、分页等等），而Gemfile是项目的配置文件（内含项目开发所需依赖项和下载源等），是利用gem进行包管理时必须的配置文件</li><li>_layouts、_includes内文档均为html类型，采用Liquid模板语言进行编写</li><li>确保username.github.io仓库中的目录结构和配置文件符合<a href="http://jekyllrb.com/docs/structure/">Jekyll官方文档</a>的定义和要求</li></ul><p>当满足：</p><ul><li>网站目录符合文档规范</li><li>Gemfile配置文件完成</li></ul><p>运行Jekyll生成网站：</p><ol><li><code>bundle install</code></li><li><code>bundle exec jekyll serve</code></li><li>浏览博客网站：<a href="http://localhost:4000/">http://localhost:4000</a></li></ol><p><strong>参考资料</strong></p><ul><li><a href="http://www.madhur.co.in/blog/2011/09/01/runningjekyllwindows.html">如何在windows平台上安装jekyll</a></li><li><a href="http://gems.ruby-china.org/">完整RrubyGem镜像</a></li><li><a href="http://blog.csdn.net/chziroy/article/details/38837715">【总结】Jekyll搭建博客</a></li><li><a href="http://www.cnblogs.com/hutaoer/archive/2013/02/06/3078873.html">win7下安装jekyll——在github上创建自己的博客</a></li><li><a href="http://sunxboy.iteye.com/blog/2171688">安装Jekyll Gem一直报Unable to download data from https://rubygems.org/的解决方案</a></li><li><a href="http://jmcglone.com/guides/github-pages/">Creating and Hosting a Personal Site on GitHub</a></li><li><a href="https://www.smashingmagazine.com/2014/08/build-blog-jekyll-github-pages/">Build A Blog With Jekyll And GitHub Pages</a></li><li><a href="https://havee.me/internet/2013-11/jekyll-liquid-designers.html">Jekyll 扩展的 Liquid 设计</a></li></ul><h3 id="4-编写Markdown文档"><a href="#4-编写Markdown文档" class="headerlink" title="4. 编写Markdown文档"></a>4. 编写Markdown文档</h3><h4 id="4-1-标题"><a href="#4-1-标题" class="headerlink" title="4.1 标题"></a>4.1 标题</h4><pre><code># 一级标题## 二级标题### 三级标题……###### 六级标题</code></pre><p>符号与标题之间<strong>空一格</strong>，是标准的语法表示。</p><p><strong>标题还可以用下面的语法</strong></p><pre><code>这是大标题=这是小标题-</code></pre><p><strong>这里要提示：</strong></p><ul><li>单个回车是空格</li><li>连续回车才是分段</li><li>行尾加两个空格，再回车，即可行内换行</li><li>头尾加*，表示斜体</li><li>头尾加**，表示粗体</li></ul><p><strong>还要提示：</strong></p><p>行的开头空四个格，表示程序代码</p><h4 id="4-2-引用"><a href="#4-2-引用" class="headerlink" title="4.2 引用"></a>4.2 引用</h4><blockquote><p><code>&gt;</code>表示引用</p></blockquote><h4 id="4-3-列表"><a href="#4-3-列表" class="headerlink" title="4.3 列表"></a>4.3 列表</h4><ul><li>无序列表前加<code>-</code> or  <code>*</code> or <code>+</code></li><li>有序列表加数字</li></ul><p><strong>注意</strong> 符号和列表项之间需要用空格分隔，就像标题的语法</p><h4 id="4-4-链接"><a href="#4-4-链接" class="headerlink" title="4.4 链接"></a>4.4 链接</h4><p><code>[]</code>中是你需要进行超链接的文本内容，后面紧跟着一对<code>()</code>,括号里面是URL。</p><p>我试着写了一个：</p><p><code>[百度一下，你就知道](http://www.baidu.com/)</code><a href="http://www.baidu.com/">百度一下，你就知道</a></p><p>图像和链接非常相似，只是在前面多加一个<code>!</code></p><p>此外还可以以索引的形式把url都列在文章的最后，例如：</p><pre><code>[图灵社区][1]![图灵社区logo][2][1]:http://www.ituring.com.cn[2]:http://www.ituring.com.cn/Content/img/Turing.Gif</code></pre><h4 id="4-5-其他"><a href="#4-5-其他" class="headerlink" title="4.5 其他"></a>4.5 其他</h4><hr><p><code>---</code>表示一条分割线<br>但是，要注意：<code>---</code>之后要回车</p><p><strong>注释</strong></p><ol><li>编写Markdown文档的时候，最好每一行后面都连续回车，行内想要换行的话，就用两个空格再回车</li><li>Markdown语言中存在HTML文档中的行内和块的概念，使用某些Markdown标记，即使不连续回车，也是换行的效果，例如<code>#</code>标题标记；而有些标记，例如<code>* *</code>强调标记，则就是行内标记；且注意行内标记后需空一格</li><li>使用Markdown编辑出来的文本，都是预制<code>CSS</code>格式，那么可以通过哪些方式修改CSS格式，美化输出的Markdown文档呢？<br>（在Markdown的文档开头添加<code>CSS</code>文档链接即可）</li><li>参考资料中提到<code>图床</code>的概念，是否为：Web中存储图片的地方，便于使用链接？<br>（图床：就是专门用来存放图片，同时允许你把图片对外连接的网上空间，不少图床都是免费的。）</li><li>Markdown中可以使用html语法，例如：你想插入额外的空行，可以使用<code>&lt;br&gt;</code>标签。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jekyll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript代码执行的in-memory-model</title>
      <link href="/2016/12/20/2016-12-20-in-memory-model-of-javascript-execution/"/>
      <url>/2016/12/20/2016-12-20-in-memory-model-of-javascript-execution/</url>
      
        <content type="html"><![CDATA[<p>如果我们能够知道JavaScript代码是如何执行的，那么就很容易理解代码，也就能够编写出更易被人理解、质量更高的代码。</p><p>执行JavaScript代码是解释器的工作，所以让我们转换一下身份，从解释器的角度出发，建立模拟JavaScript代码执行的过程模型——in-memory model。</p><p>建立的过程也即绘制in-memory model的过程，下面将根据一段代码，一步一步绘制出JavaScript代码执行的过程模型。</p><h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><pre class="brush: js">    function createFunction() {        var result = new Array();        for (var i = 0; i < 10; i++) {            result[i] = function() {                return i;            };        }        return result;    }    var result = createFunction();    var foo = result[0]();</pre><h3 id="绘制步骤"><a href="#绘制步骤" class="headerlink" title="绘制步骤"></a>绘制步骤</h3><h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><blockquote><p>黄色——执行环境</p></blockquote><blockquote><p>绿色——内存</p></blockquote><blockquote><p>蓝色——作用域链</p></blockquote><blockquote><p>白色表格——变量对象</p></blockquote><h4 id="1-global环境"><a href="#1-global环境" class="headerlink" title="1. global环境"></a>1. global环境</h4><p><img src="/images/2016-12-20-in-memory/1.png" alt="global环境"></p><h4 id="2-全局环境中的变量对象"><a href="#2-全局环境中的变量对象" class="headerlink" title="2. 全局环境中的变量对象"></a>2. 全局环境中的变量对象</h4><p><img src="/images/2016-12-20-in-memory/2.png" alt="全局环境中的变量对象"></p><h4 id="3-keep-track-of-values"><a href="#3-keep-track-of-values" class="headerlink" title="3. keep track of values"></a>3. keep track of values</h4><p>说明：</p><ul><li>变量用来指代内存中的某数据</li><li>函数一旦定义或声明，就存在一个内部属性<code>[[Scope]]</code>指向它的作用域链</li><li>作用域链由词法作用域决定</li><li>作用域链是数组，其中包含的是各个作用域中的变量对象</li><li>只当调用函数时，才会创建函数作用域中的变量对象</li></ul><p><img src="/images/2016-12-20-in-memory/3.png" alt="Keep Track of Values"></p><h4 id="4-调用createFunction函数"><a href="#4-调用createFunction函数" class="headerlink" title="4. 调用createFunction函数"></a>4. 调用createFunction函数</h4><p>说明：</p><ul><li>函数在其执行环境中被调用（原则上如此，但是绘制的时候可以不用这样，因为this指向函数执行环境对象）</li><li>函数被调用时，创建变量对象，并为其中存储的数据开辟内存空间</li><li>全局变量result中存放的是被返回的函数：闭包</li></ul><p><img src="/images/2016-12-20-in-memory/4.png" alt="调用createFunction函数"></p><h4 id="5-调用result-0-函数"><a href="#5-调用result-0-函数" class="headerlink" title="5. 调用result[0]函数"></a>5. 调用result[0]函数</h4><p>说明：</p><ul><li>首先明确，result[0]为函数，当函数作为数组的元素或者对象的方法而调用，这时叫做函数作为方法的调用，这个时候，this指向数组或对象，也即函数执行环境对象</li><li>result[0]函数体中的语句是<code>return i;</code>，执行这句语句时，即进行变量查询</li><li>变量查询根据函数的作用域链进行</li><li>在createFunction函数的变量对象中找到<code>i</code>，得到其中存储的数据</li></ul><p><img src="/images/2016-12-20-in-memory/5.png" alt="调用result[0]函数"></p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript之OOP基础概念学习总结一：scopes</title>
      <link href="/2016/11/21/2016-11-21-basis-about-javascript-oop-1-scopes/"/>
      <url>/2016/11/21/2016-11-21-basis-about-javascript-oop-1-scopes/</url>
      
        <content type="html"><![CDATA[<p>最近在探究JavaScript中的scopes概念。经过一番研究，我觉得要从Interpreter的角度，才能更好地理解这个概念。毕竟程序员主要是编写指令，而Interpreter则是把程序员编写的代码一行一行读下去并翻译出来（执行出来），最终结果就会直接反映在Web浏览器的页面上。不过还要注意的是，并不是所有的scopes都必须从Interpreter的角度去理解，lexical scope就要从编写人员的角度去理解，因为它是代码文本层面的scope，是可供程序员进行词法分析与文本理解的scope，不同于Interpreter执行代码时的scope。重点复述：lexical scope先行，是基础scope，程序员最一开始就能确定的scope，目的在于程序设计；程序的执行靠的是Interpreter对程序的解释运行，在运行期间，Interpreter专属的scope建立，也就是Interpreter所属的环境。当程序运行，就相当于进入了JavaScript语言描述的Web世界，在这里，Interpreter是个勤奋的工作者，它处在什么环境中，又要做些什么事情呢？这是接下来我要叙述的故事。</p><h3 id="1-Lexical-Scope"><a href="#1-Lexical-Scope" class="headerlink" title="1. Lexical Scope"></a>1. Lexical Scope</h3><p>为了更好地讲述这个故事，我需要一段代码，如下图所示，这是一段简化后的代码，假设它是可运行的，因为它只是一个片段。根据lexical scope分析，结果如图中不同颜色区域所示，整段代码就存在着绿红蓝的lexical scope。这是程序员根据语言规则，理解并划分出来的词法作用域。当然，前面我们已经说得很多了，这并不是代码运行时Interpreter所创建出来的作用域。<br><img src="/images/2016-11-21-scopes/1.png" alt="Lexical Scope"></p><h3 id="2-Execution-Context"><a href="#2-Execution-Context" class="headerlink" title="2. Execution Context"></a>2. Execution Context</h3><p>当执行程序，正式进入代码的世界。Interpreter开始工作，环境随之被创建，就是这么得迅速。如下图所示，最左侧的黄色箭头代表Interpreter，右侧是其工作时建立的execution context，也即工作环境。<br><img src="/images/2016-11-21-scopes/2.png" alt="Execution Context"></p><p>Interpreter开始读代码，这就是它的基本工作。<strong>读代码又要做哪些事情呢？</strong>那就要看代码中都有些什么东西了：标识符、运算符、操作符等等。</p><p>在具体分析Interpreter做什么之前，要先搞明白一个重要的概念：存储。我们都知道计算机很厉害，什么复杂的计算都能进行，那你知道计算机为什么那么厉害吗？原因之一就是它的存储能力，类比于人类的记忆力。计算机拥有100%的记忆力，只要存储介质没有损伤。这就是计算机聪明的奥义。</p><p>回到原来的问题，于是我们就应该理解到Interpreter所做的工作之一就是存储——记住它需要记住的东西。<strong>那么它需要记住哪些东西呢？</strong>主要就是标识符和数据。<br>处于某个工作环境中的Interpreter，首先要做的事情就是看看都有哪些标识符。这非常重要，必须先点名，不然之后的工作不好顺利开展。<strong>如何在当前环境中点名呢？</strong>很简单，其实也很复杂：var变量声明以及函数声明是两大重要线索。</p><h3 id="番外：声明提升"><a href="#番外：声明提升" class="headerlink" title="番外：声明提升"></a>番外：声明提升</h3><p>这里补充说明一下变量声明提升和函数声明提升的区别：</p><p>一段源代码：</p><pre class="brush: js">    alert(sum);    function sum(num1,num2) {        return num1 + num2;    }    alert(a);    var a = 10;</pre><p>声明提升后（Interpreter读完这段代码首先存储的数据）：</p><p><img src="/images/2016-11-21-scopes/4.png" alt="声明提升"></p><p>从上面storage system存储的数据中就能看出，变量声明提升之后，存储的是undefined（如果没有初始化），而函数声明的情况不同，因为函数声明时，sum中存储的便是指向函数体的指针。</p><p>也就是说，当Interpreter进入某个工作环境后，首先在当前环境中进行identifier scanning，看看有哪些var声明的变量，以及又有哪些函数声明。当它发现了这些信号后，就会把对应的标识符按照声明提升的规定、一定的顺序、以及key-value的数据结构将标识符以及相对应的数据存储在内存中。这个内存其实就是in-memory storage system，存储的内容整体叫做变量对象。Current execution context就是Interpreter当前进行variable lookingup的scope。<br><img src="/images/2016-11-21-scopes/5.png" alt="in-memory model"></p><h3 id="3-Scope-Chain"><a href="#3-Scope-Chain" class="headerlink" title="3. Scope Chain"></a>3. Scope Chain</h3><p>程序中关键内容不仅仅是标识符以及其中保存的数据。计算机程序的目的是解决问题，所以关键还得能够操作这些数据才行。操作数据就涉及到运算符、操作符等等，在我们这里并不说明这方面的内容，还是从标识符的角度去说明问题，看看在操作过程中会对标识符进行哪些操作吧。很重要的一点是：<strong>标识符的查询和解析。</strong></p><p>代码其实都是标识符的天下，当Interpreter读到一句包含各种标识符的语句时，如果里面包含着操作符，它便知道这里要进行数据操作了。<strong>怎么操作呢？</strong>面对的都是标识符，这肯定不行，因为操作的本质是对数据的操作。于是，你就能想到要把标识符中存储的数据找到才行，这便涉及到标识符的解析和查询。</p><p>因为Interpreter一开始就已经把当前环境中所有的标识符点过名了，同时也都按照key-value结构存贮在内存中。所以，只要按照一定的顺序，找到已经存储过的标识符就可以找到操作时需要的数据了。那么，<strong>按照怎样的顺序去查询标识符呢？</strong>不用担心，JavaScript语言在设计时已经设计好了规范，它提供了作用域链的概念。Interpreter知道当环境创建，不同环境中的in-memory scope确定后，内存中就有一块区域有序存放不同作用域的地址，指向不同的作用域。只要沿着这个区域中的地址线索一步一步向上搜索标识符，总会找到、或者找不到某个标识符。</p><h3 id="彩蛋：内存回收"><a href="#彩蛋：内存回收" class="headerlink" title="彩蛋：内存回收"></a>彩蛋：内存回收</h3><blockquote><p>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。（ECMAScript程序中的执行流正是由这个方便的机制控制着的）。</p></blockquote><blockquote><p>函数中局部变量的正常生命周期——局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存中分配相应的空间，以便存储它们的值。然后在函数中使用这些值，直到函数结束。此后，局部变量就没有了存在的必要了，因此可以释放他们的内存以供将来使用。</p></blockquote><blockquote><p>垃圾收集器必须跟踪哪个变量有用，哪个变量没有用，对于不再有用的变量打上标记，以备将来收回其占用的内存。</p></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>本文图片一、二、五截图自<a href="https://cn.udacity.com/course/object-oriented-javascript--ud015">Object-Oriented JavaScript</a>视频</li><li>JavaScript高级程序设计（第3版）第四章</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript之OOP基础概念学习总结二：closure</title>
      <link href="/2016/11/21/2016-11-21-basis-about-javascript-oop-2-closure/"/>
      <url>/2016/11/21/2016-11-21-basis-about-javascript-oop-2-closure/</url>
      
        <content type="html"><![CDATA[<p>闭包，我觉得并不具体指哪个函数，还是一种状态，也就是说当实际出现了满足闭包的状态时，我们就说这个是闭包。所以不能简单地把闭包理解成某个函数，毕竟看了那么多的资料，也没有感觉到到底应该把哪个函数称作闭包，最多也就是把回调函数叫做闭包。但仍有问题，因为我在用Chrome开发者工具进行JavaScript代码调试时发现，解释器将回调函数定义时所在的外层函数称为闭包。所以，我觉得闭包并不具体指哪个函数，而是指一种状态：<br><strong>当一个函数cb在另一个函数outer内定义，但也可以在outer函数之外调用（通常都是在global scope中进行调用），那么这种情况就叫做闭包。</strong>很明显，这个状态其实一共牵涉到两个主要函数，被调用的函数，以及函数被定义时的外层函数。</p><p>之所以闭包会是大家一个关注的重点，是因为JavaScript语言中，闭包结构设计的便利性。这门语言规定，你在定义域之外进行函数的调用，依然可以访问到原定义域中的变量（这种情况便是闭包效应）。也就是说，即使外层函数已经返回，按道理（一般情况下）也就失去了存在的意义，但是JavaScript允许闭包效应，所以你还是可以继续访问到外层函数中定义的变量，从而使得一切变得简单起来。</p><p>当然也会有不好的地方，比如，闭包存在，肯定会占用更多的内存空间。这是因为，既然你能够继续访问到原则上已经失去意义的外层函数，说明外层函数的内存占用并没有被标记作废。所以，原本要被清除的空间依旧存在，无形中就占用了更多的内存空间，会影响到程序运行时的性能。</p><p>总结：闭包效应是JavaScript语言设计中的必然存在，是有意为之的语言结构。</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript之OOP基础概念学习总结三：this</title>
      <link href="/2016/11/21/2016-11-21-basis-about-javascript-oop-3-this/"/>
      <url>/2016/11/21/2016-11-21-basis-about-javascript-oop-3-this/</url>
      
        <content type="html"><![CDATA[<p><strong>更新于：2017年2月20日</strong></p><h3 id="0-序言"><a href="#0-序言" class="headerlink" title="0. 序言"></a>0. 序言</h3><p>关键字this是function中的一个参数，它和函数的普通参数有两点不同：</p><ol><li>this不需要另取名字</li><li>this绑定值的方式不同（绑定值：this指向何值），一共有5种方式</li></ol><h3 id="1-关键字this与函数调用"><a href="#1-关键字this与函数调用" class="headerlink" title="1. 关键字this与函数调用"></a>1. 关键字this与函数调用</h3><p>this：在函数调用时，指代当前函数的调用环境对象。</p><p>要充分理解this，需对函数调用深入地理解。</p><p>函数调用一共有四种方式：</p><ul><li>As function 作为函数调用，或称为作为功能调用</li><li>As methods 作为方法调用</li><li>As constructors 作为构造函数调用</li><li>Indirectly through their call() and apply() methods 通过call和apply方法间接调用</li></ul><p>函数的调用，离不开函数表达式。如果函数表达式是属性获取型，那么称其为方法调用表达式。属性获取型函数表达式是指函数作为对象的方法、或者作为数组的元素（函数作为数组的元素和函数作为对象的方法是同等地位的，都是函数作为方法而调用）。函数作为方法(methods) 和功能(function) 调用的不同在于调用环境的不同，即函数的调用环境对象、函数调用时this绑定的值不同，例如当函数作为数组元素而调用时，this指向数组对象。当函数作为功能调用时，不用考虑this指代何值。因为，作为功能调用的函数，相当于是全局对象的方法，this在非严格模式下绑定到global object身上，在严格模式下为undefined。</p><p>此外，this不是变量，this是关键字，它没有作用域。内部嵌套函数的this值不会继承外层壳函数的this值。此外，this不能作为变量被赋值，但是可作为常量赋值给变量。内部嵌套函数如果是作为某个对象的方法而调用，那么这个嵌套函数的this指向的就是这个对象；如果内部嵌套函数作为功能而调用，内部嵌套函数的this指向的就是全局对象（非严格模式）或者undefined（严格模式）。</p><p>举个例子说明嵌套函数中的this绑定值的问题：</p><pre class="brush: js">var o = {                              // 一个对象 o    m: function() {                    // 对象 o 的 m 方法        var self = this;               // o.m() 调用时, this 指代 o, 变量 self 指向 o        console.log(this === o);       // "true"        f();        function f() {                 // 方法中 m 的嵌套函数 f            console.log(this === o);   // "false": f() 作为 function 被调用，this 指代 global 或 undefine            console.log(self === o);   // "true": self 是变量，缓存的是外层函数的 this 值        }    }};o.m();                                 // 调用 o.m 方法</pre><h3 id="2-this绑定值的几种情况"><a href="#2-this绑定值的几种情况" class="headerlink" title="2. this绑定值的几种情况"></a>2. this绑定值的几种情况</h3><p>function中的参数this指向何值？需明确：只有当函数被调用，JS解释器才会为this参数绑定值。</p><h4 id="2-1-当函数作为方法调用时——为this绑定值的点操作符左手边定律-dot-call"><a href="#2-1-当函数作为方法调用时——为this绑定值的点操作符左手边定律-dot-call" class="headerlink" title="2.1 当函数作为方法调用时——为this绑定值的点操作符左手边定律(dot call)"></a>2.1 当函数作为方法调用时——为this绑定值的点操作符左手边定律(dot call)</h4><p>当点操作符右手边的函数作为对象的方法而调用时，如<code>o.m();</code>，点操作符左手边的对象o作为参数传入到m函数中，绑定到参数this上。</p><h4 id="2-2-如果没有点操作符，只是调用某个方法时——this绑定默认值"><a href="#2-2-如果没有点操作符，只是调用某个方法时——this绑定默认值" class="headerlink" title="2.2 如果没有点操作符，只是调用某个方法时——this绑定默认值"></a>2.2 如果没有点操作符，只是调用某个方法时——this绑定默认值</h4><p>当没有点操作符时，也就没有左手边的对象。这种情况下，this绑定默认对象，global对象（非严格模式），或undefine（严格模式）。就像占位参数没有实际的参数传入时，会被默认的undefined值所代替一样。</p><h4 id="2-3-如果我们想把this绑定到一个对象，但是函数并不是这个对象的属性时——为this绑定其他值：函数的call方法"><a href="#2-3-如果我们想把this绑定到一个对象，但是函数并不是这个对象的属性时——为this绑定其他值：函数的call方法" class="headerlink" title="2.3 如果我们想把this绑定到一个对象，但是函数并不是这个对象的属性时——为this绑定其他值：函数的call方法"></a>2.3 如果我们想把this绑定到一个对象，但是函数并不是这个对象的属性时——为this绑定其他值：函数的call方法</h4><p>我们之前讨论的问题都是根据点操作符进行this参数的判断，那其实是有前提的：能使用点操作符说明函数是这个对象的属性，但是如果我们现在想把一个不是某个对象属性的函数的this绑定到这个对象，要怎么办呢？（肯定不能利用点操作符左手边绑定原则了，因为这个对象没有这个方法，因而也就无法通过点操作获取对象的这个方法）</p><p>使用函数的call方法可以重写this的默认值，从而设置成你希望的任意对象。</p><h4 id="番外：小剧场"><a href="#番外：小剧场" class="headerlink" title="番外：小剧场"></a>番外：小剧场</h4><p>对象A有个计算形体比例的方法<code>xtbl()</code>，非常好用。对象B知道后，也好想算算自己的形体比例，但是对象B没有这个<code>xtbl()</code>方法，也就无法计算。</p><p>对象B把自己的苦衷向对象A一顿诉说，对象A说：这个好办，我把我的<code>xtbl()</code>方法借你用就行了。</p><p>对象B破涕为笑，说：那怎么借用？</p><p>对象A说：简单，只要调用<code>A.xtbl.call(B,P1,P2,Array)</code>，你把你的身高、体重、三围的数值替换P1,P2,Array即可。</p><p>对象B一番动作后，成功算出了自己的形体比例，结果什么的不重要……不过对象B不解：怎么这么简单？这里面都发生了什么？</p><p>对象A说：<code>A.xtbl</code>表明方法是我的，然后通过<code>.call()</code>调用，将我的这个方法绑定到你的身上，同时传入方法调用时需要的基础信息，这样就可以了。</p><p>对象B：哦哦，原来是这样。</p><p>突然冒出个对象C：我也想算算形体比例…可我现在不知道自己多高、多重。</p><p>对象A：没关系，我把方法借给你，你回家量好数据再调用就可以了。</p><p>对象B：不立刻调用也行？</p><p>对象A： 是的，通过<code>var xtblCopy = A.xtbl.bind(B);</code>，C回家后，再调用<code>xtblCopy(P1,P2,Array);</code>即可。</p><p>对象B,C：哦哦。</p><h4 id="2-4-当函数作为回调函数被调用时，比如setTimeout函数中的回调函数"><a href="#2-4-当函数作为回调函数被调用时，比如setTimeout函数中的回调函数" class="headerlink" title="2.4 当函数作为回调函数被调用时，比如setTimeout函数中的回调函数"></a>2.4 当函数作为回调函数被调用时，比如setTimeout函数中的回调函数</h4><p>一开始研究函数作为setTimeout的回调函数进行调用时，只有当我们分析了setTimeout的源代码之后，才能更好地理解作为setTimeout的回调函数究竟是怎么被调用的，才能知道究竟各种参数是怎么被绑定到这个函数中的参数上的。</p><p>假设setTimeout这个函数的源代码别定义在timers.js文件中，它的内部代码如下所示：</p><pre class="brush: js">    var setTimeout = function(cb, ms) {        waitSomehow(ms);        cb(?);    };    setTimeout(o.m, 1000);  // 第 1 节中的 o.m 方法作为回调函数传入                            // 延迟 1s 调用 o.m 方法                            // 执行结果为：                            //        "false": 说明 o.m 方法中的 this 不再指代对象 o                            //        "false"                            //        "false"</pre><p>分析：</p><p>采用内存模型分析方法，关于此方法的介绍，可参考<a href="">JavaScript代码执行的in-memory-model</a>这篇文章。</p><p>cb是作为函数而调用，则其this参数、即该函数的调用环境对象为全局对象。虽然cb的函数体就是o.m的函数体，但两者的this参数值没有任何关系，this值并不是从函数体中得来，而是由函数的调用环境对象确定。</p><p>类似setImeout函数中传入函数参数存在的问题其实很常见，通过下述方法可以回调函数的this值不被重写：</p><pre class="brush: js">    setTimeout(function() {        o.m();    }, 1000);          // 执行结果为：                       //       "true" : 说明 o.m 调用时，this 指向对象 o                       //       "false"                       //       "true"</pre><p>分析：</p><p>o.m与其函数体之间的指向关系并未发生改变。此时o.m是作为对象o的方法而调用，即函数执行的环境对象是o，即this指代对象o。</p><h4 id="番外：this如果直接出现在全局作用域中，而不是出现在functional-scope中呢？"><a href="#番外：this如果直接出现在全局作用域中，而不是出现在functional-scope中呢？" class="headerlink" title="番外：this如果直接出现在全局作用域中，而不是出现在functional scope中呢？"></a>番外：this如果直接出现在全局作用域中，而不是出现在functional scope中呢？</h4><p>我们知道函数中的占位参数是局部变量，所以无法在全局作用域中访问到这个变量。this其实也是functional scope中的参数，也是局部变量，类比而言，我们也希望this不会在全局作用域中被访问到。但实际情况并非如此，this在全局下可以获取，为默认值Global。这点令人困惑，好在已经在高版本的标准中被移出了（chrome控制台中仍能获取，为默认值Global对象，也就是Window对象实例）。</p><h4 id="2-5-最后一种this绑定值的方式"><a href="#2-5-最后一种this绑定值的方式" class="headerlink" title="2.5 最后一种this绑定值的方式"></a>2.5 最后一种this绑定值的方式</h4><p>涉及到new操作函数中，this的绑定值问题。new操作并不会影响到占位参数的值绑定问题，但是this值绑定却受到很大程度的影响。new操作会导致this绑定到构造器新创建的对象上。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>关键字this的重要性在于：它是函数对象中一个重要参数，通过this参数的值绑定，就能把函数作为任何其他对象的方法进行调用（即使它不是这个对象的方法）。而且，通过this绑定不同对象，我们就能节约更多的内存，因为不需要额外的内存空间来存储方法，只要通过绑定this，就能调用其他对象的某个方法。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://cn.udacity.com/course/object-oriented-javascript--ud015">Object-Oriented JavaScript</a>相关视频</li><li>JavaScript权威指南：8.2节、8.7.4节</li><li><a href="http://stackoverflow.com/questions/15455009/javascript-call-apply-vs-bind">Javascript call() &amp; apply() vs bind()?</a></li><li><a href="http://stackoverflow.com/questions/14328519/different-in-scope-and-context-in-this-javascript-code">Different in “scope” and “context” in this Javascript code</a></li><li><a href="https://blog.kevinchisholm.com/javascript/difference-between-scope-and-context/">What is the Difference Between Scope and Context in JavaScript?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript之OOP基础概念学习总结四：prototype delegation</title>
      <link href="/2016/11/21/2016-11-21-basis-about-javascript-oop-4-prototypedelegation/"/>
      <url>/2016/11/21/2016-11-21-basis-about-javascript-oop-4-prototypedelegation/</url>
      
        <content type="html"><![CDATA[<h3 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h3><p>都说JavaScript中的一切都是对象，JavaScript中没有类，是通过对象继承对象，来实现内存节约以及代码复用的。具体实现的方法是原型链，更具体地叫做原型委托，prototype delegation：我可以没有这个属性（数据），但是我通过原型委托，循着原型链（failing lookup），从而在别的对象上找到相对应的属性（数据）和方法。</p><p>但是，你是否深入思考过，我们为什么要原型委托，为什么非得搞这么复杂的一套语言设计模式，直接老老实实地编写代码不行吗？当然可以，但是如果你真这么做，就太不懂变通了。没有解决不了的问题，所以关键是采取什么样的方法。编程人员在经历了很多之后发现：实现代码复用是非常重要的一件事。信息化技术需要的就是高效、海量，如果时间浪费在编写原本就已经存在的代码上，你的工作变得毫无意义，计算机也不会发挥出它的全部价值。所以，实现代码复用很重要，是基础建设，是每种编程语言都着重考虑的问题。编程语言中的类、继承、原型链等概念都是在为代码复用这个核心问题而服务。也是我们学习编程语言，最重要的一部分。</p><p>上面说这么多，其实就是想让自己加深对代码复用这个编程语言设计思想的印象，在此基础之上再去理解什么是原型链、对象继承，或许就不会有特别多的困扰了。突然想到之前看过的一篇文章，里面提到，人之所以会纠结、会困扰，多是因为自己不知道要去干什么。所以，当我们知道自己是要做计算机编程的核心问题之一：代码复用、节约内存占用的时候，再去学习有关原型链、继承方面的知识，也就会有些通彻了。你能够给做的每一件事都找到理由，岂不是特别得爽？</p><h3 id="代码复用的策略"><a href="#代码复用的策略" class="headerlink" title="代码复用的策略"></a>代码复用的策略</h3><p>为了实现代码复用，我们主要讨论两种策略，如下图所示：一种是直接复制需要的代码，另一种则是原型委托（我不复制，但是我和你建立联系，从而interpreter能够去你——原型对象那里继续查找）。</p><p><img src="/images/2016-11-21-prototype/1.png" alt="代码复用的策略"></p><p>第一种方式：直接复制对象，并不能随时保证同步，因为复制操作是一次性的。就像git版本控制一样，你本地更新后，远端并没有更新；远端更新后，本地并没有更新，需要手动git push 或者git pull。但是第二种方式就不一样了，因为不是复制，只是建立连接，所以对象更新后，就能直接通过连接反映过来。</p><p>现在，我们已经对比了上述两种不同的实现代码复用的策略，发现还是第二种方式更好，接下来我们就要正式深入地探究第二种方式中涉及到的原型问题了。</p><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>上面提到的第二种方式，最关键的点在于原型链。我们并不直接完全复制某对象，还是把某对象当做原型，通过委托机制（告诉某对象，我想把你做当我的原型，希望能够访问你的数据，使用你的方法），实现某对象上的属性查找。所有的对象都有一个原型链的终点，那就是Object.prototype原型对象。这里存储的属性是所有对象共有的。不管是哪条原型链上的对象，它们的属性lookup都能到达Object.prototype对象（如果属性存储在这个对象中时，比如toString方法）。</p><p><img src="/images/2016-11-21-prototype/2.png" alt="Object.prototype"></p><h3 id="Object-prototype-constructor"><a href="#Object-prototype-constructor" class="headerlink" title="Object.prototype.constructor"></a>Object.prototype.constructor</h3><p>上面我们提到了原型链的终点对象，提到这个对象中存在着一些实例对象的共享属性，现在我们就要说说其中一个属性<code>.constructor</code>。</p><p><img src="/images/2016-11-21-prototype/3.png" alt="Object.prototype.constructor"></p><blockquote><p>Like all properties, .constructor actually points to a different object that’s stored elsewhere.</p></blockquote><p>尤其需要注意的是，Object.prototype.constructor指向一个对象，也就是构造器对象，它和原型对象是两个不同的对象，存储空间不一样，所以不能混淆。</p><p>每一个对象都有constructor属性，但是这个属性其实是对象的原型对象的constructor属性。其实对象并没有local constructor property，但是它通过原型委托，沿着原型链能够在原型对象上找到这个constructor属性。实例对象最终还是间接得通过自己固有的原型属性推断自己的构造函数是哪儿个。<em>怪不得实例对象感慨：我为什么非得通过原型母亲才能知道自己的构造器父亲是谁啊。</em>所有的这一切都是因为我们要实现代码复用，减少内存占用。很多时候，我们只能通过间接的方式，也就是原型委托找到需要查询的属性，这虽然有点麻烦，但是这点麻烦在代码复用面前都是芝麻大的小事。</p><h3 id="Array-prototype"><a href="#Array-prototype" class="headerlink" title="Array.prototype"></a>Array.prototype</h3><p>如果你在创建对象的时候没有什么特别指示或者处理的话，对象的直接原型对象也即原型链的终点对象是Object.prototype对象。但是如果你做了一些特殊的指示或者要求，情况就大不相同了。这个时候，你可能需要委托其他的原型对象，比如Array.prototype对象。Array.prototype对象中存储着一些Object.prototype对象没有的属性和方法，但是也存储着和Object.prototype对象中一样的属性和方法，比如constructor属性。此外，还要注意的是，Object.prototype对象始终都是原型链的终点对象，也就是说，Array.prototype也会委托于Object.prototype。这条原型链相较于之前讨论的那条，就多了一个Array.prototype原型链节了，如下图所示：</p><p><img src="/images/2016-11-21-prototype/4.png" alt="Array.prototype"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>还记得我们正式探讨原型链前，说的那个有关代码复用的问题吗？是的，你必须时刻记得代码复用这个十分重要的编程目的。这门编程语言中有原型链的概念，就是为了让我们能够进行代码复用（共享），同时节省内存。（因为有了原型链，我们就不用再编写已经存在的属性和方法——避免重复的代码编写工作）</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>所有图片截取自<a href="https://cn.udacity.com/course/object-oriented-javascript--ud015">Object-Oriented JavaScript</a>相关视频</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web世界的上帝创物记</title>
      <link href="/2016/11/21/2016-11-21-knowing-about-web-world/"/>
      <url>/2016/11/21/2016-11-21-knowing-about-web-world/</url>
      
        <content type="html"><![CDATA[<p>上帝创造了一切，这就是JavaScript故事的核心。曾经听过一句话，JavaScript这门语言的设计出发点，是基于人类世界进行的语言设计，也就是说，这门语言是面向对象的。面向对象，基于对象，就像人类世界，所有的活动也是基于对象的。面向对象，其实也就是把Web世界类比为人类世界，JavaScript这门编程语言，也就类比于人类世界的语言。我们只能用语言来描述这个世界发生的一切，Web世界也是这样。</p><p>现在我就要用人类世界的语言描述一下上帝创物记：</p><p>世间万事万物都是上帝创造的，包括这宇宙。在时间的开头，生灵之源上帝创造了宇宙，随后花费了7天的时间创造了万物。所有的一切都是源于无，也就是说，我们整个世界都是上帝从无到有创造出来的。无生一，一生二，二生万物。</p><p>现在我们来到Web的世界，从Web的角度，用JavaScript语言把这个世界发生的一切阐述一下：</p><p>这个世界的一切也都是上帝创造的。上帝依旧是从无到有的创造了一切，也有宇宙，这个包罗万象的对象。我们要把上帝在这里的工作认真地说明白一些：他创造了一些原型，制造了一些机器，让这些机器按照对应的原型，创造出更多的物。此外，他还制造了能够生产机器的机器，来帮助他制造更多的机器，从而生产更多的物。除此之外，他发现数学是所有自然规律的本质，所以上帝创造了一个方便万物进行数学计算的物，而且这个物是独一存在的。也许在Web世界，上帝花费了更多的时间，才将Web世界的万物创造？</p><p>从上面我们可以看出，JavaScript语言描述出来的世界就是一部人类世界的翻版，所有的故事都是围绕着对象（物）展开的。所以，我们说JavaScript语言是面向对象的语言，也方便我们更好地将Web世界与人类世界相类比，从而更好地在Web世界进行创作。所以我们会说JavaScript中所有的一切都是对象。那么对象怎么来，很简单，只要有原型和构造器即可，而且对象能够继承对象，生生不息啊。</p><p>总之用JavaScript描述的Web世界中一切都是对象，属性或者方法都是对象的属性或者方法，不能脱离对象谈问题，在JavaScript这门语言中就是这样。切记！</p><p>关于宇宙对象，在JavaScript中就是全局对象。但是Web世界所说的Global对象是无法直接获取的，而是通过浏览器的window对象代理。当我们打开浏览器，一个标签页的打开，就代表我们进入了web的世界，也就说明创建了一个window对象，相当于全局对象的创建，相当于人类世界这个宇宙大环境的存在。然后，在这个大环境中，我们才有可能进一步讨论其他对象的存在，以及他们的属性和方法。计算机编程语言的存在是为了编写指令，指挥计算机解决问题。JavaScript语言中的对象，其实就是为了更好地编写指令、从而在web世界中快速解决问题而设计出来的一种编程模式。</p><p>参考资料：</p><p><a href="http://www.codeceo.com/article/javascript-world.html">JavaScript世界万物诞生记</a></p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是API？</title>
      <link href="/2016/11/13/2016-11-13-what-is-api/"/>
      <url>/2016/11/13/2016-11-13-what-is-api/</url>
      
        <content type="html"><![CDATA[<h4 id="打个比方"><a href="#打个比方" class="headerlink" title="打个比方"></a>打个比方</h4><p>W世界有很多仓库，仓库中蕴藏着丰富的资源。假设abc仓库储存着各类维生素产品。某A在进行一项研究，需要一些某种维生素。他完全可以自己从食材中提取，当然也可以调用abc仓库中的资源。考虑到自己提取维生素的费时费力，而且abc仓库可以限时免费提供资源，于是A决定直接采用abc仓库中的某类维生素。他找到abc仓库的负责人C先生，向他提出申请，很快便获得许可。剩下的就好办了：A只需根据abc仓库的官方文档，到特定的窗口取出自己所需维生素。后来，他通过研究文档，得知自己需要的维生素可以在Abc.wd2.VD.1002(aim,obj)窗口获取。当然，他本人也需要提供一些数据：用途以及对维生素的配置信息。</p><h5 id="类比结果："><a href="#类比结果：" class="headerlink" title="类比结果："></a>类比结果：</h5><ul><li><strong>W世界：</strong>  计算机的世界，当然也可以理解成Web世界</li><li><strong>abc仓库：</strong>  程序、软件、Web服务</li><li><strong>某A：</strong>  某应用</li><li><strong>某类所需维生素：</strong>  某类特定数据</li><li><strong>Abc.wd2.VD.1002(aim,obj)：</strong>  API</li></ul><p>使用API的好处：不需要搞明白别人家的仓库是怎么建造的，只需要跟着文档，选择合适的API，就能使用仓库中的资源。</p><h4 id="API是代码的窗口"><a href="#API是代码的窗口" class="headerlink" title="API是代码的窗口"></a>API是代码的窗口</h4><p>API的概念并不新鲜，和计算机程序不可分割，因为API就是某程序向外部软件世界有选择地暴露自己的窗口。</p><p><strong>某程序A说：</strong> <em>我想把自己某部分数据共享出去，所以我提供给大家一个API，诸位只要按照我对这个API的说明使用，就能共享我的数据了。</em></p><p><strong>其他程序说：</strong> <em>哦哦，那太好了，我们就不用自己编写代码了。省了好多的时间、精力、资源，还避免了某些法律纠纷。快去看看都能得到哪些数据，实现哪些功能。</em></p><p><strong>某程序A心想：</strong> <em>你们有没有想过，万一哪天我把接口关闭了呢？</em></p><p><strong>其他程序心想：</strong> <em>万一A哪天不再提供API了呢…管他呢，现在不是可用的吗？那就用起来吧，这么方便的API，一定不能错过。</em></p><h4 id="就在身边的API"><a href="#就在身边的API" class="headerlink" title="就在身边的API"></a>就在身边的API</h4><p>API的应用十分广泛，就以Web世界的应用举例说明哪些地方用到了API。比如：美团、大众点评等APP中使用了第三方的地图API；APP或者Web站点登陆时，可以通过第三方提供的API，实现微信登陆、QQ登陆、新浪微博登陆等。</p><h4 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h4><p>程序和软件有怎样的关系：</p><ul><li>程序： 可供计算机解决某个问题的一系列指令，算法+数据结构&#x3D;程序；</li><li>软件： 程序的集合，此外还包括其他文件，比如图片、文档、音频等。</li></ul><p>在API面前，你可以谈程序，也可以谈软件，因为对API而言，他们都是计算机程序。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python自学起步心得</title>
      <link href="/2016/11/11/2016-11-11-think-about-python/"/>
      <url>/2016/11/11/2016-11-11-think-about-python/</url>
      
        <content type="html"><![CDATA[<p>几个月前，买了一本电子书 <a href="http://item.jd.com/11645599.html">《趣学Python——教孩子学编程》</a>。这本书看了一小半，把基础的知识看完后，实践部分就没继续看下去。平时都是晚睡前看半个小时不到，主要找一下对这门编程语言的感觉。</p><p>最近想上一门<a href="https://cn.udacity.com/course/intro-to-computer-science--cs101">网课</a>，老师用Python语言教学，实现搜索引擎的功能，于是我内心对Python丝微的熟悉感变成了一种好感，真正开始Python入门。目前在Codecademy上学习<a href="https://www.codecademy.com/learn/python">Python基础</a>。</p><p>其实，还有一个原因促使我去学习Python。网课都是英文教学，平时学起来很吃力，好在有英文字幕。有点贪心地想：如果字幕中的有用信息全部提取出来就好了（字幕.srt文件并不便于阅读），于是就想到让计算机帮我做这件重复劳动的事。初步构想：打开字幕.srt文件，将真正的字幕信息全部写到另一个文本文件中。最一开始，我想到的是JavaScript，可惜它是Web世界的语言，无法打开文件、读取文件内容，Node.js可以，但是我还是决定用Python。</p><p>所以整个有关Python的故事就围绕着提取字幕展开了。此时，我仅在Codecademy上学了23%的Python基础知识。初生牛犊不怕虎，因为我有互联网。讲真，最不缺的就是答案，最难的是发现问题。当目标明确，知道自己要干什么，虽然不会做，但是你可以看看别人怎么做；当你发现程序运行不了、或者无法得到想要的效果，但是你可以清楚地描述存在的问题，Web世界总能出现和你类似的问题以及解答。</p><p>没有解决不了的问题。人有相似，事有相似，联想给人灵感。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jekyll到底是什么？</title>
      <link href="/2016/11/08/2016-11-08-what-is-jekyll/"/>
      <url>/2016/11/08/2016-11-08-what-is-jekyll/</url>
      
        <content type="html"><![CDATA[<p>在搭建本博客网站的过程中，参考了很多的资料，回顾后发现，这一路上也是从按部就班到半主动性。按照搜索到的流程按部就班地操作，总不能达到理想的效果，卡住，卡住，再卡住，分外忧伤。事情可以慢下来，但不能放弃。后来我调整战略，尝试理解Jekyll的运作原理，事情慢慢变得清晰，有条不紊。这篇文章不会涉及到详细的建站过程，而是从另一个角度，简述Jekyll到底是如何发挥“魔力”的。</p><h3 id="1-工作场所：Ruby平台"><a href="#1-工作场所：Ruby平台" class="headerlink" title="1. 工作场所：Ruby平台"></a>1. 工作场所：Ruby平台</h3><p>Jekyll是运行在Ruby平台上的程序，所以，最开始要搭建Jekyll的工作环境，然后再安装Jekyll工具，全部安装成功后，你就可以使用Jekyll这个强有力的工具了。</p><p>具体步骤：</p><blockquote><ul><li>安装 Ruby &amp; Ruby Development Kit (下载网址：<a href="http://rubyinstaller.org/downloads/">Ruby官网</a> )</li><li>切换到Devkit的安装目录下，然后执行 ruby dk.rb init，Edit the generated config.yml file to include installed Rubies.(一般情况下，这个文件不需要修改，直接执行下一步即可)</li><li>ruby dk.rb install</li><li>gem sources –add <a href="http://gems.ruby-china.org/">http://gems.ruby-china.org/</a> –remove <a href="http://rubygems.org/">http://rubygems.org/</a></li><li>gem install jekyll</li><li>gem install bundler</li></ul></blockquote><h3 id="2-遵守Jekyll的规矩"><a href="#2-遵守Jekyll的规矩" class="headerlink" title="2. 遵守Jekyll的规矩"></a>2. 遵守Jekyll的规矩</h3><p>按规矩好办事。想要使用Jekyll，就必须遵守Jekyll的规矩，你只有按照Jekyll世界的语言、规范，它才能乖乖为你所用。都有哪些规矩：</p><ul><li>2.1 网站项目的文件结构（结构）</li><li>2.2 HTML模板语言要求（模板和数据注入）</li></ul><p>当然，具体的规矩全部都在官方文档中。</p><h3 id="3-中场反思"><a href="#3-中场反思" class="headerlink" title="3. 中场反思"></a>3. 中场反思</h3><p>当你按照上述规矩，老老实实地把网站需要的全部数据都整理好后，就欠东风了。那么要怎样运行Jekyll，让它把我们准备的这些原材料，加工成真实网站呢？</p><h3 id="4-配置你的Jekyll工具"><a href="#4-配置你的Jekyll工具" class="headerlink" title="4. 配置你的Jekyll工具"></a>4. 配置你的Jekyll工具</h3><p>使用它，那就先配置它吧。所以，你还需要编写一个Gemfile文件。在这个文件中，需要列举你的网站项目中所有将要使用到的工具，比如jekyll，jekyll plugins等等，当然你还要提供，下载这些工具的地址，例如<code>http://rubygems.org</code>。</p><h3 id="5-使用Jekyll工具"><a href="#5-使用Jekyll工具" class="headerlink" title="5. 使用Jekyll工具"></a>5. 使用Jekyll工具</h3><p>到这里，所有的配置都搞定了。接下来就开始使用Jekyll工具，施展魔法，把我们的原始材料(符合Jekyll文档规范)加工成真实网站。运行以下步骤：</p><ul><li>5.1 bundle install</li><li>5.2 bundle exec Jekyll serve</li></ul><p><strong>解释：</strong><code>bundle install</code>之后，便把我们列举在配置文件中的工具全部安装起来（拿起我们的魔术棒）；运行<code>bundle exec jekyll serve</code>，Jekyll开始实时工作，即通过它提供的本地服务器进行本地预览（无需联网），你对文件所做的修改，都会直接反映出来，<code>localhost:4000</code>刷新后，便能看到修改后的效果。</p><p>还要继续解释一下<code>jekyll serve</code>：前台所做的各种修改，都会被后台运行的Jekyll实时地加工、“翻译”、“施展魔法”成真实网站，而且，你能够通过<code>localhost:4000</code>本地预览网站。此外，你可以和<code>jekyll build</code>做对比：<code>jekyll build</code>只是将原始材料“翻译”成真实网站（_site文件夹出现），实现<code>jekyll serve</code>的部分功能，但是不会像<code>Jekyll serve</code>那样，可以本地预览，实时加工。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当然，上述步骤2-5.1可以通过运行<code>jekyll new your-website-name</code>命令，利用Jekyll自动生成网站结构、Gemfile预定义配置以及相关工具的安装。这也是网上大部分的流程步骤。不过，有关网站的具体内容还是要你自己探索，虽然生成的网站也是有预定义的内容的（也就是Jekyll Theme），但太过简单，你肯定不会特别满意。这里插一句话，Jekyll Theme其实就是一个完整的Website了。你如果从GitHub上fork了一个你相中的主题，只需要修改一下网站的名称等原作者相关信息后，就可以变成你的网站了。</p><h3 id="结尾反思"><a href="#结尾反思" class="headerlink" title="结尾反思"></a>结尾反思</h3><p>在参考的资料中有两篇印象特别深刻，<a href="http://jmcglone.com/guides/github-pages/">一篇</a>是在github上利用github提供的接口原生态的实践jekyll的全部步骤。这篇很基础，给我提供了别样的思路，让我能够深入地思考jekyll的运作原理。<a href="https://www.smashingmagazine.com/2014/08/build-blog-jekyll-github-pages/">另外一篇</a>是传授我们如何利用GitHub上的Jekyll Theme快速搭建自己的博客网站，让我更进一步理解Jekyll文件的编写、HTML模板语法的使用等，让我渐渐不再对Jekyll感到束手无策、毫无头绪，不会再有那种它就是我眼前，却远在天边的感觉。</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jekyll </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
